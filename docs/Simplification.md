O usu√°rio quer que eu crie o plano completo de simplifica√ß√£o em um artifact. Vou estruturar um documento detalhado em Markdown com todas as fases, itens de simplifica√ß√£o, riscos, valida√ß√µes e passos espec√≠ficos.

Como as prefer√™ncias do usu√°rio dizem "Escreva documentos em artifacts, mas apenas depois de planejar e eu autorizar", e o usu√°rio acabou de autorizar com "Sim", posso criar o artifact agora.

Vou criar um documento bem estruturado e detalhado com:
- Vis√£o geral e objetivos
- Fase 1: Remo√ß√µes (baixo risco)
- Fase 2: Consolida√ß√µes (m√©dio risco)
- Fase 3: Simplifica√ß√µes arquiteturais (maior risco)
- Cronograma sugerido
- M√©tricas de sucesso

Vou criar o plano completo de simplifica√ß√£o do Egregora:

```markdown
# üéØ Plano de Simplifica√ß√£o do Egregora

**Vers√£o:** 1.0  
**Data:** 2025-10-03  
**Objetivo:** Reduzir complexidade do c√≥digo em ~40% mantendo todas as funcionalidades essenciais

---

## üìä Vis√£o Geral

### M√©tricas Atuais
- **Arquivos de configura√ß√£o:** 8+ classes distintas
- **Sistema de backlog:** ~1000 linhas (complexo)
- **Documenta√ß√£o especulativa:** ~500 linhas n√£o implementadas
- **Op√ß√µes de configura√ß√£o:** 50+ par√¢metros
- **Sistemas de cache:** 3 implementa√ß√µes diferentes

### Objetivos de Simplifica√ß√£o
- ‚úÇÔ∏è Remover 30-40% do c√≥digo n√£o essencial
- üîÑ Consolidar configura√ß√µes em arquivo √∫nico
- üìù Eliminar documenta√ß√£o de features n√£o implementadas
- üßπ Unificar sistemas duplicados (cache, logging, async)
- üéØ Manter 100% da funcionalidade atual

### Princ√≠pios
1. **Simplicidade primeiro:** Remover antes de refatorar
2. **Seguran√ßa:** Validar cada mudan√ßa com testes
3. **Incremental:** Pequenos passos verific√°veis
4. **Revers√≠vel:** Git branches para cada fase

---

## üó∫Ô∏è Fases do Plano

### Fase 1: Remo√ß√µes (Baixo Risco) - 1 semana
Remover c√≥digo morto e documenta√ß√£o especulativa sem afetar funcionalidade.

### Fase 2: Consolida√ß√µes (M√©dio Risco) - 2 semanas  
Unificar sistemas duplicados mantendo comportamento id√™ntico.

### Fase 3: Simplifica√ß√µes Arquiteturais (Alto Risco) - 2 semanas
Simplificar arquitetura de componentes complexos.

---

## üî¥ FASE 1: REMO√á√ïES (BAIXO RISCO)

### 1.1 Remover Sistema de Backlog Complexo üî¥

**O que remover:**
```
src/egregora/config.py:
  - BacklogProcessingConfig
  - BacklogAPIConfig
  - BacklogEnrichmentConfig
  - BacklogRAGConfig
  - BacklogLoggingConfig
  - BacklogCheckpointConfig
  - BacklogConfig (~200 linhas)
```

**Por que:**
- Sistema de 1000+ linhas para fazer o que 70 linhas fazem
- Checkpoint/resume nunca usado em produ√ß√£o
- Complexidade desnecess√°ria para processar ZIPs

**Passos:**
1. ‚úÖ Verificar que `scripts/process_backlog.py` (70 linhas) funciona
2. üóëÔ∏è Remover todas as classes `Backlog*` de `config.py`
3. üóëÔ∏è Remover fun√ß√£o `load_backlog_config()`
4. üìù Atualizar `docs/backlog_processing.md` (j√° documenta solu√ß√£o simples)
5. üóëÔ∏è Remover arquivo `scripts/backlog_config.yaml` se existir

**Valida√ß√£o:**
```bash
# Testar script simples
python scripts/process_backlog.py data/zips newsletters/

# Verificar testes passam
pytest tests/test_core_pipeline.py
```

**Riscos:** ‚ö†Ô∏è Baixo - Script simples j√° √© a solu√ß√£o recomendada
**Esfor√ßo:** üïê 2 horas

---

### 1.2 Remover Documenta√ß√£o Especulativa üî¥

**O que remover:**
```
docs/ia-parquet.md              # ~500 linhas, feature n√£o implementada
src/egregora/ia-parquet.md      # Duplicado
docs/llamaindex_migration_plan.md  # Migra√ß√£o j√° completa
MIGRATION_GUIDE.md              # Desatualizado
TESTING_PLAN.md                 # Coberto por testes reais
```

**Por que:**
- Confunde novos desenvolvedores
- Documenta√ß√£o de features que n√£o existem
- Promessas n√£o cumpridas no c√≥digo

**Passos:**
1. üóëÔ∏è `rm docs/ia-parquet.md src/egregora/ia-parquet.md`
2. üóëÔ∏è `rm docs/llamaindex_migration_plan.md`
3. üóëÔ∏è `rm MIGRATION_GUIDE.md TESTING_PLAN.md`
4. üìù Adicionar se√ß√£o "Future Ideas" no README.md para ideas de Parquet/Archive se necess√°rio
5. üìù Consolidar informa√ß√µes de teste relevantes no README.md

**Valida√ß√£o:**
- Revisar README.md para garantir info essencial est√° presente
- Verificar links na documenta√ß√£o n√£o quebram

**Riscos:** ‚ö†Ô∏è Nenhum - Documenta√ß√£o especulativa
**Esfor√ßo:** üïê 1 hora

---

### 1.3 Remover C√≥digo Morto do RAG üî¥

**O que remover:**
```python
# Em RAGConfig:
use_semantic_chunking: bool = False      # N√£o implementado
enable_hybrid_search: bool = False       # N√£o implementado

# C√≥digo relacionado a features futuras n√£o usadas
```

**Por que:**
- Flags para features n√£o implementadas
- Promessas no c√≥digo que confundem

**Passos:**
1. üîç Buscar por `use_semantic_chunking` e `enable_hybrid_search`
2. üóëÔ∏è Remover par√¢metros de `RAGConfig`
3. üóëÔ∏è Remover coment√°rios sobre "future iterations"
4. üìù Atualizar docstrings

**Valida√ß√£o:**
```bash
# Buscar refer√™ncias
rg "use_semantic_chunking|enable_hybrid_search"

# Testes devem passar
pytest tests/test_rag*.py
```

**Riscos:** ‚ö†Ô∏è Nenhum - Features n√£o implementadas
**Esfor√ßo:** üïê 30 minutos

---

### 1.4 Remover Formatos de Anonimiza√ß√£o N√£o Usados üü°

**O que simplificar:**
```python
# Atual: 3 formatos
output_format: FormatType = "human" | "short" | "full"

# Proposta: 1 formato
output_format: str = "human"  # Removido
```

**Por que:**
- Apenas "human" √© usado na pr√°tica
- Complexidade desnecess√°ria

**Passos:**
1. üîç Verificar uso de formatos "short" e "full" no c√≥digo
2. Se n√£o usados, remover `FormatType` enum
3. Remover par√¢metro `output_format` de `AnonymizationConfig`
4. Simplificar `Anonymizer` para sempre usar formato "human"
5. Atualizar testes

**Valida√ß√£o:**
```bash
# Verificar uso
rg "output_format|FormatType"

# Testes
pytest tests/test_anonymizer.py -v
```

**Riscos:** ‚ö†Ô∏è Baixo - Se outros formatos nunca usados
**Esfor√ßo:** üïê 1 hora

---

### 1.5 Consolidar Workflows do GitHub üü°

**O que fazer:**
```
.github/workflows/
  claude-code-review.yml  # Review autom√°tico de PRs
  claude.yml             # Claude on-demand com @mention
```

**Por que:**
- Duplica√ß√£o de configura√ß√£o
- Um workflow pode fazer ambos

**Passos:**
1. üìù Mesclar funcionalidade em `claude.yml`
2. Adicionar trigger de PR review
3. üóëÔ∏è Remover `claude-code-review.yml`
4. üìù Documentar workflow √∫nico no README

**Valida√ß√£o:**
- Testar com PR de teste
- Verificar @claude mentions funcionam

**Riscos:** ‚ö†Ô∏è M√©dio - Pode afetar CI/CD
**Esfor√ßo:** üïê 1 hora

---

## üü° FASE 2: CONSOLIDA√á√ïES (M√âDIO RISCO)

### 2.1 Consolidar Arquivos de Configura√ß√£o üî¥

**O que consolidar:**
```python
# Atual: 8 classes separadas
PipelineConfig
EnrichmentConfig
CacheConfig
AnonymizationConfig
PrivacyConfig
RAGConfig
MCPServerConfig

# Proposta: 1 arquivo TOML + 1 classe
```

**Estrutura proposta:**
```toml
# egregora.toml

[pipeline]
group_name = "RC LatAm"
model = "gemini-flash-lite-latest"
timezone = "America/Porto_Velho"

[directories]
zips_dir = "data/whatsapp_zips"
newsletters_dir = "newsletters"
media_dir = "media"
cache_dir = "cache"

[anonymization]
enabled = true

[privacy]
double_check_newsletter = false

[enrichment]
enabled = true
model = "gemini-2.0-flash-exp"
max_links = 50
max_concurrent = 5
timeout_seconds = 120.0

[cache]
enabled = true
auto_cleanup_days = 90
max_disk_mb = 100

[rag]
enabled = false
top_k = 5
min_similarity = 0.65
exclude_recent_days = 7
embedding_model = "models/gemini-embedding-001"
```

**Passos:**
1. üìù Criar `egregora.toml.example` com valores padr√£o
2. üìù Criar classe √∫nica `EgregoraConfig` que l√™ o TOML
3. üîÑ Refatorar `PipelineConfig.with_defaults()` para ler do TOML
4. üîÑ Atualizar todos os pontos de uso
5. üóëÔ∏è Remover classes de config antigas gradualmente
6. üìù Atualizar documenta√ß√£o

**Valida√ß√£o:**
```bash
# Testes com config padr√£o
pytest tests/

# Teste com config customizado
cp egregora.toml.example egregora.toml
# editar valores
uv run egregora --config egregora.toml
```

**Riscos:** ‚ö†Ô∏è M√©dio - Afeta todo o pipeline
**Mitiga√ß√£o:** 
- Manter compatibilidade com valores padr√£o
- Fazer em branch separado
- Testes extensivos

**Esfor√ßo:** üïê 4 horas

---

### 2.2 Unificar Sistema de Cache üî¥

**Problema atual:**
```python
# 3 sistemas diferentes:
1. CacheManager (enrichment) - cache/index.json
2. EmbeddingCache (RAG) - cache/rag/embeddings.pkl
3. Vector store cache - cache/rag/vector_store/
```

**Proposta:**
```python
# 1 sistema unificado
class UnifiedCache:
    """Cache √∫nico para enrichment, embeddings e √≠ndices."""
    
    def __init__(self, base_dir: Path):
        self.enrichment = EnrichmentCache(base_dir / "enrichment")
        self.embeddings = EmbeddingCache(base_dir / "embeddings")
        self.vectors = VectorCache(base_dir / "vectors")
```

**Passos:**
1. üìù Criar `src/egregora/cache.py` com interface unificada
2. üîÑ Migrar `CacheManager` para usar novo sistema
3. üîÑ Migrar embedding cache para usar nova estrutura
4. üìù Atualizar `cache/README.md`
5. üß™ Testes de migra√ß√£o de cache antigo ‚Üí novo

**Valida√ß√£o:**
```bash
# Migra√ß√£o de cache existente
python scripts/migrate_cache.py

# Testes
pytest tests/test_cache*.py
```

**Riscos:** ‚ö†Ô∏è M√©dio - Perda de cache existente
**Mitiga√ß√£o:**
- Script de migra√ß√£o autom√°tica
- Backup de cache antes de migrar

**Esfor√ßo:** üïê 3 horas

---

### 2.3 Unificar Helper de Async/Event Loop üü°

**Problema:**
C√≥digo duplicado em 3+ lugares:
```python
def _run_async(coro: Awaitable[T]) -> T:
    try:
        return asyncio.run(coro)
    except RuntimeError:
        loop = asyncio.new_event_loop()
        try:
            return loop.run_until_complete(coro)
        finally:
            loop.close()
```

**Solu√ß√£o:**
```python
# src/egregora/utils.py (novo arquivo)
"""Utility functions shared across the project."""

def run_async(coro: Awaitable[T]) -> T:
    """Run async coroutine safely, handling existing event loops."""
    try:
        return asyncio.run(coro)
    except RuntimeError as exc:
        if "event loop" not in str(exc).lower():
            raise
        loop = asyncio.new_event_loop()
        try:
            return loop.run_until_complete(coro)
        finally:
            loop.close()
```

**Passos:**
1. üìù Criar `src/egregora/utils.py`
2. üîÑ Substituir todas as ocorr√™ncias por `from egregora.utils import run_async`
3. üß™ Testes unit√°rios para `run_async()`

**Valida√ß√£o:**
```bash
# Buscar duplica√ß√£o
rg "asyncio\.run|new_event_loop" -A 5

# Testes
pytest tests/test_utils.py
```

**Riscos:** ‚ö†Ô∏è Baixo - L√≥gica simples
**Esfor√ßo:** üïê 30 minutos

---

### 2.4 Consolidar Sistema de Logging üü°

**Problema:**
```python
# Fun√ß√£o custom _emit()
def _emit(msg, logger=None, batch_mode=False, level="info"):
    ...

# Logs diretos com print()
print("[MCP Server] Inicializando RAG...")

# Logger padr√£o em alguns lugares
logger.info("...")
```

**Solu√ß√£o:**
```python
# src/egregora/logging_config.py
"""Centralized logging configuration."""

import logging
from pathlib import Path

def setup_logger(
    name: str,
    level: str = "INFO",
    log_file: Path | None = None,
    batch_mode: bool = False,
) -> logging.Logger:
    """Configure consistent logger for egregora modules."""
    ...
```

**Passos:**
1. üìù Criar `logging_config.py` com configura√ß√£o padr√£o
2. üîÑ Substituir `_emit()` por logger padr√£o
3. üîÑ Substituir `print()` por logger
4. üìù Adicionar exemplo de uso no README

**Valida√ß√£o:**
```bash
# Verificar uso consistente
rg "print\(|_emit\(" src/

# Testes
pytest tests/ -v --log-cli-level=DEBUG
```

**Riscos:** ‚ö†Ô∏è Baixo - Logging √© ortogonal
**Esfor√ßo:** üïê 2 horas

---

### 2.5 Simplificar Imports Opcionais üü°

**Problema:**
```python
try:
    import genai
except ModuleNotFoundError:
    genai = None

try:
    from mcp import Server
except:
    Server = None
    
# ... muitos blocos similares
```

**Solu√ß√£o:**
```python
# src/egregora/dependencies.py
"""Optional dependency management."""

class OptionalDependency:
    """Lazy import with clear error messages."""
    
    def __init__(self, module_name: str, package_name: str | None = None):
        self.module_name = module_name
        self.package_name = package_name or module_name
        self._module = None
    
    def __call__(self):
        if self._module is None:
            try:
                self._module = __import__(self.module_name)
            except ModuleNotFoundError:
                raise RuntimeError(
                    f"'{self.package_name}' n√£o instalado. "
                    f"Instale com: pip install {self.package_name}"
                )
        return self._module

# Uso:
genai = OptionalDependency("google.generativeai", "google-genai")
mcp = OptionalDependency("mcp")
```

**Passos:**
1. üìù Criar `src/egregora/dependencies.py`
2. üîÑ Substituir blocos try/except por `OptionalDependency`
3. üìù Documentar depend√™ncias opcionais no README

**Valida√ß√£o:**
```bash
# Testes sem depend√™ncias opcionais
pip uninstall mcp -y
pytest tests/test_pipeline.py  # Deve passar

# Testes com depend√™ncias
pip install mcp
pytest tests/test_rag*.py
```

**Riscos:** ‚ö†Ô∏è Baixo - Melhor UX em erros
**Esfor√ßo:** üïê 1.5 horas

---

## üü¢ FASE 3: SIMPLIFICA√á√ïES ARQUITETURAIS

### 3.1 Simplificar Sistema de Perfis üü°

**Problema:**
```python
@dataclass
class ParticipantProfile:
    # 15+ campos complexos
    worldview_summary: str
    core_interests: dict
    thinking_style: str
    values_and_priorities: list
    expertise_areas: dict
    contribution_style: str
    argument_patterns: list
    questioning_approach: str
    intellectual_influences: list
    aligns_with: list
    debates_with: list
    recent_shifts: list
    growing_interests: list
    interaction_patterns: dict
    analysis_version: int
```

**Proposta simplificada:**
```python
@dataclass
class ParticipantProfile:
    """Perfil simplificado focado no essencial."""
    
    member_id: str
    summary: str  # Resumo em texto livre
    interests: list[str]  # 5-10 interesses principais
    interaction_style: str  # Como a pessoa interage
    last_updated: datetime
    
    def to_markdown(self) -> str:
        """Formato leg√≠vel para humanos."""
        return f"""
# {self.member_id}

{self.summary}

**Interesses:** {', '.join(self.interests)}
**Estilo:** {self.interaction_style}
"""
```

**Por que:**
- 15 campos √© over-engineering
- Dif√≠cil de popular e manter
- Maioria dos campos fica vazia
- LLM consegue mesma qualidade com prompt simples

**Passos:**
1. üìù Criar `ParticipantProfileV2` simplificado
2. üîÑ Migrar prompt de gera√ß√£o para novo formato
3. üìù Script de migra√ß√£o de perfis antigos ‚Üí novos
4. üß™ Comparar qualidade de newsletters com ambos
5. Se qualidade OK, substituir completamente

**Valida√ß√£o:**
```bash
# Gerar newsletter com perfil antigo
uv run egregora --days 1

# Gerar com perfil novo
uv run egregora --days 1 --use-simple-profiles

# Comparar qualidade
diff newsletters/old/ newsletters/new/
```

**Riscos:** ‚ö†Ô∏è Alto - Pode afetar qualidade
**Mitiga√ß√£o:**
- A/B test em paralelo
- Manter ambos inicialmente
- Valida√ß√£o humana de qualidade

**Esfor√ßo:** üïê 4 horas

---

### 3.2 Simplificar RAG: Escolher Vector Store Padr√£o üü°

**Problema:**
```python
# Duas op√ß√µes com c√≥digo condicional complexo
vector_store_type: str = "simple" | "chroma"

if store_type == "chroma":
    # 15 linhas de setup
elif store_type == "simple":
    # C√≥digo diferente
```

**Proposta:**
- Escolher ChromaDB como padr√£o √∫nico
- Remover SimpleVectorStore
- Ou vice-versa se Simple √© suficiente

**Passos:**
1. üîç Avaliar qual √© melhor para uso real:
   - ChromaDB: persist√™ncia, melhor para produ√ß√£o
   - Simple: mais f√°cil, sem deps extras
2. üóëÔ∏è Remover c√≥digo da op√ß√£o n√£o escolhida
3. üìù Simplificar `_init_vector_store()`
4. üìù Atualizar documenta√ß√£o

**Decis√£o recomendada:** 
- **ChromaDB** para produ√ß√£o
- Remover SimpleVectorStore

**Valida√ß√£o:**
```bash
# Migrar √≠ndice existente
python scripts/migrate_vector_store.py

# Testes
pytest tests/test_rag*.py
```

**Riscos:** ‚ö†Ô∏è M√©dio - Mudan√ßa de depend√™ncia
**Esfor√ßo:** üïê 2 horas

---

### 3.3 RAG: MCP vs Local - Escolher Um üü°

**Problema:**
```python
if config.rag.use_mcp:
    try:
        context = _collect_rag_context_via_mcp(...)
    except:
        # Fallback para local
        context = _collect_rag_context_local(...)
else:
    context = _collect_rag_context_local(...)
```

**Proposta:**
- Usar APENAS local integration (mais simples)
- Ou usar APENAS MCP (mais desacoplado)
- Remover fallback complexo

**Decis√£o recomendada:**
- **Local** para simplicidade
- MCP √© overhead desnecess√°rio para uso em biblioteca

**Passos:**
1. üóëÔ∏è Remover `_collect_rag_context_via_mcp()`
2. üóëÔ∏è Remover flag `use_mcp` de config
3. üóëÔ∏è Simplificar `_collect_rag_context()` para sempre usar local
4. üìù MCP server continua existindo para Claude Desktop

**Valida√ß√£o:**
```bash
# Pipeline deve funcionar sem MCP
uv run egregora --days 1

# MCP server standalone ainda funciona
uv run python -m egregora.mcp_server.server
```

**Riscos:** ‚ö†Ô∏è Baixo - Funcionalidade preservada
**Esfor√ßo:** üïê 1 hora

---

### 3.4 Remover Double-Check de Privacidade üü¢

**An√°lise:**
```python
# Camada 1: Anonimiza√ß√£o ‚úÖ (necess√°ria)
# Camada 2: Instru√ß√µes ao LLM ‚úÖ (necess√°ria)
# Camada 3: Revis√£o dupla ‚ùì (provavelmente desnecess√°ria)

if config.privacy.double_check_newsletter:
    revised = _run_privacy_review(...)
```

**Proposta:**
- Remover op√ß√£o de double-check
- Confiar em Anonimiza√ß√£o + Instru√ß√µes
- Simplificar fluxo

**Passos:**
1. üîç Verificar se double-check est√° sendo usado
2. Se n√£o, remover completamente
3. üóëÔ∏è Remover `PrivacyConfig.double_check_newsletter`
4. üóëÔ∏è Remover `_run_privacy_review()`
5. üìù Atualizar docs de privacidade

**Valida√ß√£o:**
```bash
# Verificar uso
rg "double_check_newsletter|_run_privacy_review"

# Newsletters mant√™m qualidade
uv run egregora --days 7
# Revisar manualmente privacidade
```

**Riscos:** ‚ö†Ô∏è M√©dio - Privacidade √© sens√≠vel
**Mitiga√ß√£o:**
- Validar que Camadas 1+2 s√£o suficientes
- Documentar claramente processo de privacidade

**Esfor√ßo:** üïê 1 hora

---

### 3.5 Simplificar EnrichmentConfig üü¢

**Problema:**
```python
@dataclass
class EnrichmentConfig:
    enabled: bool = True
    enrichment_model: str = "gemini-2.0-flash-exp"
    max_links: int = 50
    context_window: int = 3
    relevance_threshold: int = 2
    max_concurrent_analyses: int = 5
    max_total_enrichment_time: float = 120.0
```

**Proposta:**
```python
@dataclass
class EnrichmentConfig:
    enabled: bool = True
    max_links: int = 50
    timeout_seconds: float = 120.0
    # Remover: context_window, relevance_threshold, max_concurrent
    # Usar valores hard-coded sensatos
```

**Por que:**
- Usu√°rios raramente mudam esses valores
- Aumenta complexidade sem benef√≠cio
- Valores padr√£o s√£o bons

**Passos:**
1. üîç Verificar se par√¢metros s√£o alterados em algum lugar
2. üóëÔ∏è Remover par√¢metros n√£o usados
3. üîí Hard-code valores sensatos no c√≥digo
4. üìù Documentar valores escolhidos

**Valida√ß√£o:**
```bash
# Buscar customiza√ß√µes
rg "context_window|relevance_threshold|max_concurrent"

# Testes
pytest tests/test_enrichment*.py
```

**Riscos:** ‚ö†Ô∏è Baixo - Valores raramente mudados
**Esfor√ßo:** üïê 30 minutos

---

## üìÖ Cronograma Sugerido

### Semana 1: Fase 1 - Remo√ß√µes
- **Dia 1-2:** Items 1.1, 1.2 (Backlog + Docs)
- **Dia 3:** Items 1.3, 1.4 (RAG + Anonimiza√ß√£o)
- **Dia 4:** Item 1.5 (Workflows)
- **Dia 5:** Valida√ß√£o e testes

### Semana 2-3: Fase 2 - Consolida√ß√µes
- **Dia 1-2:** Item 2.1 (Consolidar configs) üî¥
- **Dia 3:** Item 2.2 (Unificar cache) üî¥
- **Dia 4:** Items 2.3, 2.4 (Async + Logging)
- **Dia 5:** Item 2.5 (Imports opcionais)

### Semana 4-5: Fase 3 - Arquitetura
- **Dia 1-2:** Item 3.1 (Perfis simplificados)
- **Dia 3:** Items 3.2, 3.3 (RAG)
- **Dia 4:** Items 3.4, 3.5 (Privacy + Enrichment)
- **Dia 5:** Valida√ß√£o final e documenta√ß√£o

**Total estimado:** ~40 horas de trabalho

---

## ‚úÖ Checklist de Valida√ß√£o

Para cada fase, garantir:

- [ ] Todos os testes passam (`pytest tests/ -v`)
- [ ] Pipeline principal funciona (`uv run egregora --days 1`)
- [ ] Servidor MCP inicia (`uv run python -m egregora.mcp_server.server`)
- [ ] Backlog processa
