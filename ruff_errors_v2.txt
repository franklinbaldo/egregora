FIX002 Line contains TODO, consider resolving the issue
  --> src/egregora/agents/avatar.py:83:3
   |
83 | # TODO: [Taskmaster] Refactor: Move hardcoded UUID namespace to configuration
   |   ^^^^
84 | def _generate_avatar_uuid(content: bytes) -> uuid.UUID:
85 |     """Generate deterministic UUID for avatar based on content only.
   |

E501 Line too long (119 > 110)
   --> src/egregora/agents/avatar.py:133:111
    |
131 |                 raise AvatarProcessingError(msg)
132 |             if mime_type != expected_mime:
133 |                 msg = f"Image content type mismatch: content appears to be {mime_type} but declared as {expected_mime}"
    |                                                                                                               ^^^^^^^^^
134 |                 raise AvatarProcessingError(msg)
135 |             return
    |

E501 Line too long (138 > 110)
   --> src/egregora/agents/avatar.py:152:111
    |
150 | â€¦
151 | â€¦IMENSION:
152 | â€¦t} pixels. Maximum allowed: {MAX_IMAGE_DIMENSION}x{MAX_IMAGE_DIMENSION} pixels."
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
153 | â€¦
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/agents/avatar.py:281:3
    |
281 | # TODO: [Taskmaster] Refactor: Decompose `download_avatar_from_url` to simplify logic
    |   ^^^^
282 | @sleep_and_retry
283 | @limits(calls=10, period=60)
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/agents/avatar.py:332:7
    |
330 |         msg = f"Too many redirects (>{MAX_REDIRECT_HOPS}) for URL: {url}"
331 |         raise AvatarProcessingError(msg) from e
332 |     # TODO: [Taskmaster] Refactor: Simplify complex error handling block
    |       ^^^^
333 |     except httpx.HTTPError as e:
334 |         # If the HTTP error was caused by our own validation, re-raise it directly
    |

ERA001 Found commented-out code
  --> src/egregora/agents/banner/gemini_provider.py:76:9
   |
74 |         # Disabled until API support is consistent or model version is updated.
75 |         # if request.aspect_ratio:
76 |         #     payload["request"]["generation_config"]["aspectRatio"] = request.aspect_ratio
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
77 |
78 |         return payload
   |
help: Remove commented-out code

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> src/egregora/agents/commands.py:134:16
    |
132 |             date = timestamp.split("T")[0]  # Fallback to date part
133 |     else:
134 |         date = datetime.now().date().isoformat()
    |                ^^^^^^^^^^^^^^
135 |
136 |     # Generate content based on command type
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

FIX002 Line contains TODO, consider resolving the issue
  --> src/egregora/agents/enricher.py:72:3
   |
70 | # ---------------------------------------------------------------------------
71 |
72 | # TODO: [Taskmaster] Externalize hardcoded configuration values
   |   ^^^^
73 | HEARTBEAT_INTERVAL = 10  # Seconds for heartbeat logging
   |

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/agents/enricher.py:159:13
    |
157 |             response = await client.get(jina_url, headers=headers, timeout=30.0)
158 |             response.raise_for_status()
159 |             return response.text
    |             ^^^^^^^^^^^^^^^^^^^^
160 |         except (httpx.RequestError, httpx.HTTPStatusError) as exc:
161 |             return f"Jina fetch failed: {exc}"
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/agents/enricher.py:234:3
    |
234 | # TODO: [Taskmaster] Refactor brittle data conversion logic
    |   ^^^^
235 | def _frame_to_records(frame: Any) -> list[dict[str, Any]]:
236 |     """Convert backend frames into dict records consistently."""
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/agents/enricher.py:318:3
    |
318 | # TODO: [Taskmaster] Refactor duplicated enrichment check logic
    |   ^^^^
319 | def _enqueue_url_enrichments(
320 |     messages_table: Table,
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/agents/enricher.py:472:3
    |
472 | # TODO: [Taskmaster] Decompose monolithic EnrichmentWorker class
    |   ^^^^
473 | class EnrichmentWorker(BaseWorker):
474 |     """Worker for media enrichment (e.g. image description)."""
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/agents/enricher.py:594:7
    |
592 |         return self._persist_url_results(results)
593 |
594 |     # TODO: [Taskmaster] Simplify complex async-in-sync wrapper
    |       ^^^^
595 |     def _enrich_single_url(self, task_data: dict) -> tuple[dict, EnrichmentOutput | None, str | None]:
596 |         """Enrich a single URL with fallback support (sync wrapper)."""
    |

BLE001 Do not catch blind exception: `Exception`
   --> src/egregora/agents/enricher.py:748:20
    |
746 |                 logger.info("[URLEnricher] Using single-call batch mode for %d URLs", total)
747 |                 return self._execute_url_single_call(tasks_data)
748 |             except Exception as single_call_exc:
    |                    ^^^^^^^^^
749 |                 logger.warning(
750 |                     "[URLEnricher] Single-call batch failed (%s), falling back to individual",
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/agents/enricher.py:784:7
    |
782 |         return results
783 |
784 |     # TODO: [Taskmaster] Decompose complex batch execution method
    |       ^^^^
785 |     def _execute_url_single_call(
786 |         self, tasks_data: list[dict[str, Any]]
    |

FIX002 Line contains TODO, consider resolving the issue
    --> src/egregora/agents/enricher.py:1033:7
     |
1031 |         return requests, task_map
1032 |
1033 |     # TODO: [Taskmaster] Simplify complex file staging logic
     |       ^^^^
1034 |     def _stage_file(self, task: dict[str, Any], payload: dict[str, Any]) -> Path:
1035 |         """Extract media file from ZIP to ephemeral staging directory."""
     |

TRY301 Abstract `raise` to an inner function
    --> src/egregora/agents/enricher.py:1069:17
     |
1067 |             if not full_path:
1068 |                 msg = f"Media file {original_filename} not found in ZIP"
1069 |                 raise MediaStagingError(msg)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1070 |
1071 |             safe_name = f"{task['task_id']}_{Path(full_path).name}"
     |

TRY300 Consider moving this statement to an `else` block
    --> src/egregora/agents/enricher.py:1081:13
     |
1080 |             self.staged_files.add(str(target_path))
1081 |             return target_path
     |             ^^^^^^^^^^^^^^^^^^
1082 |         except Exception as exc:
1083 |             msg = f"Failed to stage media file {original_filename}: {exc}"
     |

BLE001 Do not catch blind exception: `Exception`
    --> src/egregora/agents/enricher.py:1349:20
     |
1347 |                 logger.info("[MediaEnricher] Processed %s via individual call", tag)
1348 |
1349 |             except Exception as exc:
     |                    ^^^^^^^^^
1350 |                 logger.warning("[MediaEnricher] Individual call failed for %s: %s", tag, exc)
1351 |                 result = type(
     |

FIX002 Line contains TODO, consider resolving the issue
    --> src/egregora/agents/enricher.py:1508:19
     |
1507 |                 # Using SQL replace to update all occurrences
1508 |                 # TODO: [Taskmaster] Refactor to use parameterized queries to prevent SQL injection
     |                   ^^^^
1509 |                 try:
1510 |                     # We need to use valid SQL string escaping
     |

E501 Line too long (140 > 110)
    --> src/egregora/agents/enricher.py:1517:111
     |
1515 | â€¦ning this ref.
1516 | â€¦mestamps), this is safe.
1517 | â€¦lace(text, '{safe_original}', '{safe_new}') WHERE text LIKE '%{safe_original}%'"
     |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1518 | â€¦
1519 | â€¦
     |

FIX002 Line contains TODO, consider resolving the issue
    --> src/egregora/agents/enricher.py:1533:7
     |
1531 |         return len(results)
1532 |
1533 |     # TODO: [Taskmaster] Improve brittle JSON parsing from LLM output
     |       ^^^^
1534 |     def _parse_media_result(self, res: Any, task: dict[str, Any]) -> tuple[dict[str, Any], str, str] | None:
1535 |         text = self._extract_text(res.response)
     |

TRY300 Consider moving this statement to an `else` block
  --> src/egregora/agents/formatting.py:38:9
   |
36 |     try:
37 |         doc = output_sink.read_document(DocumentType.JOURNAL, latest.identifier)
38 |         return doc.content
   |         ^^^^^^^^^^^^^^^^^^
39 |     except DocumentNotFoundError:
40 |         return ""
   |

SIM108 Use ternary operator `aspect = title_parts[1].strip() if len(title_parts) > 1 else title` instead of `if`-`else`-block
  --> src/egregora/agents/profile/generator.py:91:5
   |
89 |       # Extract meaningful part from title (remove author name prefix if present)
90 |       title_parts = title.split(":", 1)
91 | /     if len(title_parts) > 1:
92 | |         # Title like "John Doe: Technical Contributions" -> use "Technical Contributions"
93 | |         aspect = title_parts[1].strip()
94 | |     else:
95 | |         aspect = title
   | |______________________^
96 |
97 |       # Slugify the aspect
   |
help: Replace `if`-`else`-block with `aspect = title_parts[1].strip() if len(title_parts) > 1 else title`

E501 Line too long (160 > 110)
   --> src/egregora/agents/profile/generator.py:197:111
    |
196 | â€¦
197 | â€¦, contradict the current profile, or show a meaningful evolution in their stance/interests?
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
198 | â€¦ignificant' to False.
199 | â€¦ appreciative profile update.
    |

G004 Logging statement uses f-string
   --> src/egregora/agents/profile/generator.py:414:30
    |
413 |         except (ValueError, TypeError) as e:
414 |             logger.exception(f"Failed to generate profile for {author_name}: {e}")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
415 |             continue
    |
help: Convert to lazy `%` formatting

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/agents/profile/generator.py:414:79
    |
413 |         except (ValueError, TypeError) as e:
414 |             logger.exception(f"Failed to generate profile for {author_name}: {e}")
    |                                                                               ^
415 |             continue
    |

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/agents/profile/history.py:178:13
    |
177 |             logger.info("Loaded %d profile posts for %s from database", len(posts), author_uuid)
178 |             return posts
    |             ^^^^^^^^^^^^
179 |
180 |         except ibis.common.exceptions.IbisError as e:
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> src/egregora/agents/profile/history.py:213:24
    |
211 |             else:
212 |                 # Fallback for non-standard naming
213 |                 date = datetime.now().strftime("%Y-%m-%d")
    |                        ^^^^^^^^^^^^^^
214 |                 aspect = "General Profile"
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

E501 Line too long (173 > 110)
   --> src/egregora/agents/shared/annotations/__init__.py:238:111
    |
237 | â€¦
238 | â€¦t_created\n            ON {ANNOTATIONS_TABLE} (parent_id, parent_type, created_at)\n            "
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
239 | â€¦
    |

E501 Line too long (130 > 110)
   --> src/egregora/agents/shared/annotations/__init__.py:270:111
    |
268 |         # We also provide empty 'id' and 'source_checksum' to satisfy BASE_COLUMNS if needed,
269 |         # but id is handled by sequence and source_checksum is nullable/defaulted usually.
270 |         # Actually BASE_COLUMNS has source_checksum as string. We should probably provide it or let default handle it if nullable?
    |                                                                                                               ^^^^^^^^^^^^^^^^^^^^
271 |         # Looking at schema, source_checksum is string.
272 |         # Let's check schemas.py again. BASE_COLUMNS: "source_checksum": dt.string
    |

BLE001 Do not catch blind exception: `Exception`
   --> src/egregora/agents/shared/annotations/__init__.py:303:20
    |
301 |             try:
302 |                 self.output_sink.persist(annotation.to_document())
303 |             except Exception as exc:
    |                    ^^^^^^^^^
304 |                 logger.warning("Failed to persist annotation %s: %s", annotation.id, exc)
    |

E501 Line too long (277 > 110)
   --> src/egregora/agents/shared/annotations/__init__.py:315:111
    |
313 | â€¦
314 | â€¦
315 | â€¦, created_at\n            FROM {ANNOTATIONS_TABLE}\n            WHERE parent_id = ? AND parent_type = 'message'\n            ORDER BY created_at ASC, id ASC\n            ",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
316 | â€¦
317 | â€¦
    |

E501 Line too long (211 > 110)
   --> src/egregora/agents/shared/annotations/__init__.py:325:111
    |
323 | â€¦
324 | â€¦
325 | â€¦ = ? AND parent_type = 'message'\n            ORDER BY created_at DESC, id DESC\n            LIMIT 1\n            ",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
326 | â€¦
327 | â€¦
    |

E501 Line too long (215 > 110)
   --> src/egregora/agents/shared/annotations/__init__.py:334:111
    |
332 | â€¦
333 | â€¦
334 | â€¦mmentary, created_at\n            FROM {ANNOTATIONS_TABLE}\n            ORDER BY created_at ASC, id ASC\n            "
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
335 | â€¦
336 | â€¦
    |

FIX002 Line contains TODO, consider resolving the issue
 --> src/egregora/agents/taxonomy.py:2:3
  |
1 | """Pydantic-AI agent for generating semantic taxonomy from content clusters."""
2 | # TODO: [Taskmaster] Move function-level imports to the top of the file
  |   ^^^^
3 | # TODO: [Taskmaster] Add docstrings to Pydantic models
4 | # TODO: [Taskmaster] Refactor brittle model name prefix stripping
  |

FIX002 Line contains TODO, consider resolving the issue
 --> src/egregora/agents/taxonomy.py:3:3
  |
1 | """Pydantic-AI agent for generating semantic taxonomy from content clusters."""
2 | # TODO: [Taskmaster] Move function-level imports to the top of the file
3 | # TODO: [Taskmaster] Add docstrings to Pydantic models
  |   ^^^^
4 | # TODO: [Taskmaster] Refactor brittle model name prefix stripping
  |

FIX002 Line contains TODO, consider resolving the issue
 --> src/egregora/agents/taxonomy.py:4:3
  |
2 | # TODO: [Taskmaster] Move function-level imports to the top of the file
3 | # TODO: [Taskmaster] Add docstrings to Pydantic models
4 | # TODO: [Taskmaster] Refactor brittle model name prefix stripping
  |   ^^^^
5 |
6 | from pydantic import BaseModel, Field
  |

E501 Line too long (168 > 110)
  --> src/egregora/agents/taxonomy.py:52:111
   |
51 | â€¦
52 | â€¦ython Basics" and Cluster 2 is "Python Async", do NOT tag both just "Python". Distinguish them.
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
53 | â€¦
54 | â€¦specific (Topic).
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> src/egregora/agents/tools/skill_injection.py:140:16
    |
138 |     except Exception as e:
139 |         error_msg = f"Sub-agent execution failed: {e}"
140 |         logger.error(error_msg, exc_info=True)
    |                ^^^^^
141 |         return f"ERROR: {error_msg}"
    |

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/agents/writer.py:302:9
    |
300 |         params.output_sink.persist(doc)
301 |         logger.info("Saved journal entry: %s", doc.document_id)
302 |         return doc.document_id
    |         ^^^^^^^^^^^^^^^^^^^^^^
303 |     except (TemplateNotFound, TemplateError) as exc:
304 |         msg = f"Journal template error for window {params.window_label}: {exc}"
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/agents/writer.py:442:56
    |
440 |                 result = _run_agent_sync(loop)
441 |     except Exception as e:
442 |         logger.exception("Error during agent run: %s", e)
    |                                                        ^
443 |         raise
444 |     finally:
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/agents/writer.py:472:7
    |
470 |             raise AgentError(msg)
471 |     intercalated_log = _extract_intercalated_log(messages)
472 |     # TODO: [Taskmaster] Refactor complex journal fallback logic
    |       ^^^^
473 |     if not intercalated_log:
474 |         fallback_content = _extract_journal_content(result.all_messages())
    |

SIM102 Use a single `if` statement instead of nested `if` statements
   --> src/egregora/agents/writer.py:594:5
    |
592 |           return True
593 |
594 | /     if isinstance(exc, ModelHTTPError):
595 | |         # Always cycle on client/server errors
596 | |         if exc.status_code >= 400:
    | |__________________________________^
597 |               return True
    |
help: Combine `if` statements using `and`

PLR2004 Magic value used in comparison, consider replacing `400` with a constant variable
   --> src/egregora/agents/writer.py:596:31
    |
594 |     if isinstance(exc, ModelHTTPError):
595 |         # Always cycle on client/server errors
596 |         if exc.status_code >= 400:
    |                               ^^^
597 |             return True
    |

SIM103 Return the condition directly
   --> src/egregora/agents/writer.py:599:5
    |
597 |               return True
598 |
599 | /     if isinstance(exc, RuntimeError) and "event loop is closed" in str(exc).lower():
600 | |         return True
601 | |
602 | |     # Default to not cycling for unknown errors
603 | |     return False
    | |________________^
604 |
605 |       def _should_cycle(exc: Exception) -> bool:
    |
help: Inline condition

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/agents/writer.py:703:17
    |
701 |                 )
702 |                 _KEY_ROTATION_INDEX = (current_key_idx + 1) % num_keys if num_keys > 0 else 0
703 |                 return result
    |                 ^^^^^^^^^^^^^
704 |             except PromptTooLargeError:
705 |                 raise
    |

SIM102 Use a single `if` statement instead of nested `if` statements
   --> src/egregora/agents/writer.py:715:21
    |
713 |                   )
714 |                   if _should_cycle(exc):
715 | /                     if isinstance(exc, ModelHTTPError) and "openrouter" in model_name:
716 | |                         if affordable := _get_openrouter_affordable_tokens(exc):
717 | |                             if openrouter_max_tokens is None or affordable < openrouter_max_tokens:
    | |___________________________________________________________________________________________________^
718 |                                   openrouter_max_tokens = affordable
719 |                                   logger.warning("[WriterRotation] Retrying with affordable token limit: %d", affordable)
    |
help: Combine `if` statements using `and`

SIM102 Use a single `if` statement instead of nested `if` statements
   --> src/egregora/agents/writer.py:716:25
    |
714 |                   if _should_cycle(exc):
715 |                       if isinstance(exc, ModelHTTPError) and "openrouter" in model_name:
716 | /                         if affordable := _get_openrouter_affordable_tokens(exc):
717 | |                             if openrouter_max_tokens is None or affordable < openrouter_max_tokens:
    | |___________________________________________________________________________________________________^
718 |                                   openrouter_max_tokens = affordable
719 |                                   logger.warning("[WriterRotation] Retrying with affordable token limit: %d", affordable)
    |
help: Combine `if` statements using `and`

F821 Undefined name `_get_openrouter_affordable_tokens`
   --> src/egregora/agents/writer.py:716:42
    |
714 |                 if _should_cycle(exc):
715 |                     if isinstance(exc, ModelHTTPError) and "openrouter" in model_name:
716 |                         if affordable := _get_openrouter_affordable_tokens(exc):
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
717 |                             if openrouter_max_tokens is None or affordable < openrouter_max_tokens:
718 |                                 openrouter_max_tokens = affordable
    |

E501 Line too long (119 > 110)
   --> src/egregora/agents/writer.py:719:111
    |
717 |                             if openrouter_max_tokens is None or affordable < openrouter_max_tokens:
718 |                                 openrouter_max_tokens = affordable
719 |                                 logger.warning("[WriterRotation] Retrying with affordable token limit: %d", affordable)
    |                                                                                                               ^^^^^^^^^
720 |                                 continue
721 |                     logger.warning("[WriterRotation] Cycling to next key/model.")
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/agents/writer.py:763:3
    |
763 | # TODO: [Taskmaster] Refactor complex `write_posts_for_window` function
    |   ^^^^
764 | def write_posts_for_window(params: WindowProcessingParams) -> dict[str, Any]:
765 |     """Public entry point for the writer agent."""
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/agents/writer.py:807:11
    |
805 |     )
806 |     if cached_result:
807 |         # TODO: [Taskmaster] Refactor brittle cache validation logic
    |           ^^^^
808 |         # Validate cached posts still exist on disk (they may be missing if output dir is fresh)
809 |         cached_posts = cached_result.get(RESULT_KEY_POSTS, [])
    |

BLE001 Do not catch blind exception: `Exception`
   --> src/egregora/agents/writer_helpers.py:366:16
    |
364 |         try:
365 |             return asyncio.run(model.count_tokens(prompt))
366 |         except Exception:
    |                ^^^^^^^^^
367 |             logger.debug("Native token counting failed, falling back to estimation")
    |

TRY301 Abstract `raise` to an inner function
   --> src/egregora/cli/diagnostics.py:206:13
    |
204 |         if not git_path:
205 |             msg = "git executable not found"
206 |             raise FileNotFoundError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
207 |
208 |         result = subprocess.run(
    |

ERA001 Found commented-out code
  --> src/egregora/cli/main.py:24:1
   |
22 | from egregora.cli.diagnostics import HealthStatus, run_diagnostics
23 |
24 | # from egregora.cli.db import db_app  # Removed - db.py no longer exists
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 | from egregora.cli.read import read_app
26 | from egregora.config import load_egregora_config
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> src/egregora/cli/main.py:44:1
   |
43 | # Database subcommands
44 | # app.add_typer(db_app)  # Removed - db.py no longer exists
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
45 |
46 | # Show subcommands
   |
help: Remove commented-out code

E501 Line too long (123 > 110)
   --> src/egregora/cli/main.py:117:111
    |
115 | â€¦     f"ðŸ“ Docs directory: {docs_dir}\n\n"
116 | â€¦     f"[bold]Next steps:[/bold]\n"
117 | â€¦     f"1. Generate content:\n   [cyan]egregora write path/to/chat_export.zip --output-dir {output_dir}[/cyan]\n"
    |                                                                                                     ^^^^^^^^^^^^^
118 | â€¦     f"2. Preview the site:\n   [cyan]cd {output_dir}[/cyan]\n   [cyan]uv tool run --with mkdocs-material --with mkdocs-blogging-pluâ€¦
119 | â€¦     title="ðŸ› ï¸ Initialization Complete",
    |

E501 Line too long (346 > 110)
   --> src/egregora/cli/main.py:118:111
    |
116 | â€¦
117 | â€¦put_dir}[/cyan]\n"
118 | â€¦cs-material --with mkdocs-blogging-plugin --with mkdocs-macros-plugin --with mkdocs-rss-plugin --with mkdocs-glightbox --with mkdocs-git-revision-date-localized-plugin --with mkdocs-minify-plugin mkdocs serve -f .egregora/mkdocs.yml[/cyan]",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
119 | â€¦
120 | â€¦
    |

E501 Line too long (260 > 110)
   --> src/egregora/cli/main.py:126:111
    |
124 | â€¦
125 | â€¦
126 | â€¦ting setup:\nâ€¢ Docs directory: {docs_dir}\n\n[bold]To update or regenerate:[/bold]\nâ€¢ Manually edit [cyan]mkdocs.yml[/cyan] or remove it to reinitialize.",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
127 | â€¦
128 | â€¦
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/cli/main.py:133:3
    |
133 | # TODO: [Taskmaster] Refactor the write command to use a Pydantic model for its parameters.
    |   ^^^^
134 | @app.command()
135 | def write(
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/cli/main.py:207:3
    |
207 | # TODO: [Taskmaster] Refactor site validation logic into a reusable utility function.
    |   ^^^^
208 | @app.command()
209 | def top(
    |

E501 Line too long (125 > 110)
   --> src/egregora/cli/main.py:422:111
    |
421 |     # 3. Create a placeholder index
422 |     index_content = "# Welcome to Egregora\n\nThis is a demo site. See the first post [here](./posts/2025-01-01-welcome.md)."
    |                                                                                                               ^^^^^^^^^^^^^^^
423 |     (output_dir / "docs" / "index.md").write_text(index_content)
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/cli/main.py:426:3
    |
426 | # TODO: [Taskmaster] Decouple the demo command from the test fixtures.
    |   ^^^^
427 | @app.command()
428 | def demo(
    |

E501 Line too long (294 > 110)
   --> src/egregora/cli/main.py:487:111
    |
485 | â€¦
486 | â€¦
487 | â€¦ocs-macros-plugin --with mkdocs-rss-plugin --with mkdocs-glightbox --with mkdocs-git-revision-date-localized-plugin --with mkdocs-minify-plugin mkdocs serve -f .egregora/mkdocs.yml[/cyan]",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
488 | â€¦
489 | â€¦
    |

E501 Line too long (133 > 110)
   --> src/egregora/cli/main.py:535:112
    |
533 | â€¦
534 | â€¦
535 | â€¦) found. Egregora should work but some features may be limited.[/bold yellow]"
    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^
536 | â€¦
537 | â€¦
    |

E501 Line too long (115 > 110)
   --> src/egregora/cli/main.py:539:110
    |
537 |     else:
538 |         console.print(
539 |             f"[bold red]âŒ {error_count} error(s) found. Please fix these issues before using Egregora.[/bold red]"
    |                                                                                                               ^^^^^
540 |         )
    |

E501 Line too long (127 > 110)
   --> src/egregora/config/settings.py:288:111
    |
286 |     strategy: Literal["individual", "batch_api", "batch_all"] = Field(
287 |         default="batch_all",
288 |         description="Enrichment strategy: individual (1 call per item), batch_api (Gemini batch), batch_all (all in one call)",
    |                                                                                                               ^^^^^^^^^^^^^^^^^
289 |     )
290 |     model_rotation_enabled: bool = Field(
    |

E501 Line too long (139 > 110)
   --> src/egregora/config/settings.py:363:111
    |
361 | â€¦
362 | â€¦
363 | â€¦k, even if model supports more). Prevents context overflow and controls costs.",
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
364 | â€¦
365 | â€¦
    |

E501 Line too long (132 > 110)
   --> src/egregora/config/settings.py:376:111
    |
374 |     checkpoint_enabled: bool = Field(
375 |         default=False,
376 |         description="Enable incremental processing with checkpoints (opt-in). Default: always rebuild from scratch for simplicity.",
    |                                                                                                               ^^^^^^^^^^^^^^^^^^^^^^
377 |     )
    |

E501 Line too long (119 > 110)
   --> src/egregora/config/settings.py:390:111
    |
388 |     egregora_dir: str = Field(
389 |         default=".egregora",
390 |         description="Directory for Egregora internal artifacts (rag, cache). Config lives in root .egregora.toml now.",
    |                                                                                                               ^^^^^^^^^
391 |     )
392 |     # The following paths default to being inside egregora_dir
    |

E501 Line too long (136 > 110)
   --> src/egregora/config/settings.py:473:111
    |
471 | â€¦
472 | â€¦
473 | â€¦ (e.g., 'mkdocs.yml'), relative to site root. If None, uses default location.",
    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^
474 | â€¦
    |

E501 Line too long (114 > 110)
   --> src/egregora/config/settings.py:553:111
    |
551 |     default_source: str | None = Field(
552 |         default="whatsapp",
553 |         description="Default source key to run when none is provided (set to null to run all configured sources)",
    |                                                                                                               ^^^^
554 |     )
555 |     sources: dict[str, SourceSettings] = Field(
    |

ERA001 Found commented-out code
   --> src/egregora/data_primitives/document.py:117:5
    |
115 |     type: DocumentType
116 |
117 |     # Metadata (format-agnostic)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
118 |     metadata: dict[str, Any] = field(default_factory=dict)
    |
help: Remove commented-out code

SIM102 Use a single `if` statement instead of nested `if` statements
   --> src/egregora/data_primitives/document.py:166:9
    |
164 |           # 2. Semantic Identity (Slug)
165 |           # Only for Posts and Media, as per Pure spec
166 | /         if self.type in (DocumentType.POST, DocumentType.MEDIA):
167 | |             # Do NOT call self.slug property here to avoid recursion fallback loop
168 | |             if cleaned_slug := self._clean_slug(self.metadata.get("slug")):
    | |___________________________________________________________________________^
169 |                   return cleaned_slug
    |
help: Combine `if` statements using `and`

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/database/duckdb_manager.py:246:21
    |
244 |                     Path(db_str).unlink(missing_ok=True)
245 |                     _connect()
246 |                     return
    |                     ^^^^^^
247 |                 except (OSError, duckdb.Error):
248 |                     logger.exception("Failed to recover via file deletion")
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/database/duckdb_manager.py:677:86
    |
675 |                     values = _fetch_values()
676 |                 except duckdb.Error as retry_exc:
677 |                     logger.exception("Retry after connection reset also failed: %s", retry_exc)
    |                                                                                      ^^^^^^^^^
678 |                     raise SequenceRetryFailedError(sequence_name) from retry_exc
    |

G004 Logging statement uses f-string
  --> src/egregora/database/migrations.py:62:17
   |
61 |     create_sql = _build_create_table_sql(temp_table_name)
62 |     logger.info(f"Creating temporary table: {temp_table_name}")
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
63 |     conn.execute(create_sql)
   |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
  --> src/egregora/database/migrations.py:66:17
   |
65 |     insert_sql = _build_insert_select_sql(temp_table_name, existing_columns)
66 |     logger.info(f"Copying data to temporary table: {temp_table_name}")
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
67 |     conn.execute(insert_sql)
   |
help: Convert to lazy `%` formatting

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/database/profile_cache.py:200:9
    |
199 |         logger.debug("Retrieved %d profiles from database", len(profiles))
200 |         return profiles
    |         ^^^^^^^^^^^^^^^
201 |     except Exception as e:
202 |         logger.warning("Failed to read profiles from DB: %s", e)
    |

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/database/profile_cache.py:232:9
    |
231 |         logger.debug("Found %d opted-out authors in database", len(opted_out))
232 |         return opted_out
    |         ^^^^^^^^^^^^^^^^
233 |     except Exception as e:
234 |         logger.warning("Failed to read opted-out authors from DB: %s", e)
    |

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/database/profile_cache.py:388:9
    |
387 |         logger.debug("Retrieved %d profile posts for %s from database", len(posts), author_uuid)
388 |         return posts
    |         ^^^^^^^^^^^^
389 |     except Exception as e:
390 |         logger.warning("Failed to read profile posts from DB for %s: %s", author_uuid, e)
    |

ERA001 Found commented-out code
  --> src/egregora/database/repository.py:47:21
   |
45 |                     "date": doc.internal_metadata.get("date"),
46 |                     "summary": doc.summary,
47 |                     # "authors": [str(a.id) for a in doc.authors],
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
48 |                     # "tags": [c.term for c in doc.categories],
49 |                     "status": doc.status,
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> src/egregora/database/repository.py:48:21
   |
46 |                     "summary": doc.summary,
47 |                     # "authors": [str(a.id) for a in doc.authors],
48 |                     # "tags": [c.term for c in doc.categories],
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
49 |                     "status": doc.status,
50 |                 }
   |
help: Remove commented-out code

ERA001 Found commented-out code
   --> src/egregora/database/repository.py:182:9
    |
180 |         # if row.get("authors"):
181 |         #     # Assuming row['authors'] is list of strings (UUIDs)
182 |         #     authors = [Author(id=uid, name="") for uid in row["authors"]]
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
183 |
184 |         # if row.get("tags"):
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> src/egregora/database/repository.py:185:9
    |
184 |         # if row.get("tags"):
185 |         #     categories = [Category(term=tag) for tag in row["tags"]]
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
186 |
187 |         return Document(
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> src/egregora/database/repository.py:193:13
    |
191 |             updated=row.get("created_at"),  # Map created_at back to updated?
192 |             summary=row.get("summary"),
193 |             # authors=authors,
    |             ^^^^^^^^^^^^^^^^^^
194 |             # categories=categories,
195 |             doc_type=doc_type,
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> src/egregora/database/repository.py:194:13
    |
192 |             summary=row.get("summary"),
193 |             # authors=authors,
194 |             # categories=categories,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
195 |             doc_type=doc_type,
196 |             internal_metadata=internal_metadata,
    |
help: Remove commented-out code

E501 Line too long (113 > 110)
   --> src/egregora/database/schemas.py:370:111
    |
368 |     SELECT id, 'journal' as type, content, created_at, title, NULL as slug, NULL as subject_uuid FROM journals
369 |     UNION ALL
370 |     SELECT id, 'media' as type, content, created_at, NULL as title, NULL as slug, NULL as subject_uuid FROM media
    |                                                                                                               ^^^
371 |     UNION ALL
372 |     SELECT id, 'annotation' as type, content, created_at, NULL as title, NULL as slug, NULL as subject_uuid FROM annotations
    |

E501 Line too long (124 > 110)
   --> src/egregora/database/schemas.py:372:111
    |
370 |     SELECT id, 'media' as type, content, created_at, NULL as title, NULL as slug, NULL as subject_uuid FROM media
371 |     UNION ALL
372 |     SELECT id, 'annotation' as type, content, created_at, NULL as title, NULL as slug, NULL as subject_uuid FROM annotations
    |                                                                                                               ^^^^^^^^^^^^^^
373 | """
    |

E501 Line too long (121 > 110)
  --> src/egregora/database/streaming/stream.py:48:111
   |
46 |     """
47 |     if not hasattr(con, "con"):
48 |         msg = f"Backend {type(con).__name__} doesn't expose DuckDB connection. stream_ibis requires ibis.duckdb backend."
   |                                                                                                               ^^^^^^^^^^^
49 |         raise AttributeError(msg)
50 |     return con.con
   |

E501 Line too long (111 > 110)
  --> src/egregora/input_adapters/iperon_tjro.py:61:111
   |
59 |     def generation_instructions(self) -> str:
60 |         return (
61 |             "Treat each message as an official court notice. Highlight the case context, the tribunal action, "
   |                                                                                                               ^
62 |             "and why it matters for IPERON rather than speculating beyond the published communication."
63 |         )
   |

G004 Logging statement uses f-string
  --> src/egregora/input_adapters/self_reflection.py:57:28
   |
55 |             documents.append(doc)
56 |         except (OSError, yaml.YAMLError) as e:
57 |             logger.warning(f"Failed to parse {md_file}: {e}")
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
58 |     return documents
   |
help: Convert to lazy `%` formatting

DTZ011 `datetime.date.today()` used
  --> src/egregora/input_adapters/self_reflection.py:83:17
   |
81 |     @property
82 |     def generation_instructions(self) -> str:
83 |         today = date.today().isoformat()
   |                 ^^^^^^^^^^^^
84 |         return (
85 |             "You are reviewing posts that you already wrote. Only create a new post when you can "
   |
help: Use `datetime.datetime.now(tz=...).date()` instead

TRY301 Abstract `raise` to an inner function
   --> src/egregora/input_adapters/whatsapp/adapter.py:99:17
    |
 97 |             if not input_path.exists():
 98 |                 msg = f"Input path does not exist: {input_path}"
 99 |                 raise FileNotFoundError(msg)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
100 |             if not input_path.is_file() or not str(input_path).endswith(".zip"):
101 |                 msg = f"Expected a ZIP file, got: {input_path}"
    |

TRY301 Abstract `raise` to an inner function
   --> src/egregora/input_adapters/whatsapp/adapter.py:102:17
    |
100 |             if not input_path.is_file() or not str(input_path).endswith(".zip"):
101 |                 msg = f"Expected a ZIP file, got: {input_path}"
102 |                 raise ValueError(msg)
    |                 ^^^^^^^^^^^^^^^^^^^^^
103 |
104 |             group_name, chat_file = discover_chat_file(input_path)
    |

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/input_adapters/whatsapp/adapter.py:121:13
    |
120 |             logger.debug("Parsed WhatsApp export with %s messages", messages_table.count().execute())
121 |             return messages_table
    |             ^^^^^^^^^^^^^^^^^^^^^
122 |         except (FileNotFoundError, ValueError) as e:
123 |             logger.exception("Validation failed for input path %s: %s", input_path, e)
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/input_adapters/whatsapp/adapter.py:123:85
    |
121 |             return messages_table
122 |         except (FileNotFoundError, ValueError) as e:
123 |             logger.exception("Validation failed for input path %s: %s", input_path, e)
    |                                                                                     ^
124 |             msg = f"Invalid input path: {input_path}"
125 |             raise WhatsAppAdapterError(msg) from e
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/input_adapters/whatsapp/adapter.py:127:81
    |
125 |             raise WhatsAppAdapterError(msg) from e
126 |         except zipfile.BadZipFile as e:
127 |             logger.exception("Invalid ZIP file provided at %s: %s", input_path, e)
    |                                                                                 ^
128 |             raise InvalidZipFileError(str(input_path)) from e
129 |         except WhatsAppParsingError as e:
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/input_adapters/whatsapp/adapter.py:130:87
    |
128 |             raise InvalidZipFileError(str(input_path)) from e
129 |         except WhatsAppParsingError as e:
130 |             logger.exception("Failed to parse WhatsApp export at %s: %s", input_path, e)
    |                                                                                       ^
131 |             msg = f"Failed to parse WhatsApp export: {e}"
132 |             raise WhatsAppAdapterError(msg) from e
    |

DTZ007 Naive datetime constructed using `datetime.datetime.strptime()` without %z
   --> src/egregora/input_adapters/whatsapp/parsing.py:155:20
    |
153 |     for fmt in _DATE_FORMATS:
154 |         try:
155 |             return datetime.strptime(normalized, fmt).date()
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
156 |         except ValueError:
157 |             continue
    |
help: Call `.replace(tzinfo=<timezone>)` or `.astimezone()` to convert to an aware datetime

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/knowledge/profiles.py:211:7
    |
210 |     """
211 |     # TODO: [Taskmaster] Refactor get_active_authors for clarity and efficiency
    |       ^^^^
212 |     system_authors = ["system", "egregora", ""]
213 |     query = table.filter(table.author_uuid.notin(system_authors))
    |

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/knowledge/profiles.py:379:9
    |
377 |         profile_path = _find_profile_path(author_uuid, profiles_dir)
378 |         content = profile_path.read_text(encoding="utf-8")
379 |         return profile_path, content
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
380 |     except ProfileNotFoundError:
381 |         front_matter = {"uuid": author_uuid, "subject": author_uuid}
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/knowledge/profiles.py:388:7
    |
386 | def _apply_command_transformation(cmd_type: str, target: str, value: Any, ctx: CommandContext) -> str:
387 |     """Apply a single command transformation to the profile content."""
388 |     # TODO: [Taskmaster] Refactor command handlers for better organization
    |       ^^^^
389 |     content = _handle_alias_command(cmd_type, target, value, ctx)
390 |     ctx.content = content
    |

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/knowledge/profiles.py:532:9
    |
530 |     try:
531 |         profile_content = read_profile(author_uuid, profiles_dir)
532 |         return "Status: OPTED OUT" in profile_content
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
533 |     except ProfileNotFoundError:
534 |         # If a profile doesn't exist, the user cannot have opted out.
    |

DTZ006 `datetime.datetime.fromtimestamp()` called without a `tz` argument
   --> src/egregora/knowledge/profiles.py:900:17
    |
899 |     try:
900 |         mtime = datetime.fromtimestamp(path.stat().st_mtime)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
901 |         return mtime.date()
902 |     except OSError:
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

E501 Line too long (119 > 110)
  --> src/egregora/llm/api_keys.py:80:111
   |
78 |         # Provide clear error message based on error type
79 |         if "invalid" in error_msg.lower() or "api key" in error_msg.lower():
80 |             msg = f"Invalid Gemini API key. Please check your GOOGLE_API_KEY environment variable.\nError: {error_msg}"
   |                                                                                                               ^^^^^^^^^
81 |         elif "quota" in error_msg.lower():
82 |             msg = f"Gemini API quota exceeded. Please check your API quota.\nError: {error_msg}"
   |

E501 Line too long (113 > 110)
  --> src/egregora/llm/api_keys.py:84:111
   |
82 |             msg = f"Gemini API quota exceeded. Please check your API quota.\nError: {error_msg}"
83 |         elif "permission" in error_msg.lower() or "403" in error_msg:
84 |             msg = f"Permission denied for Gemini API. Please check your API key permissions.\nError: {error_msg}"
   |                                                                                                               ^^^
85 |         else:
86 |             msg = f"Failed to validate Gemini API key. Please check your network connection and API key.\nError: {error_msg}"
   |

E501 Line too long (125 > 110)
  --> src/egregora/llm/api_keys.py:86:111
   |
84 |             msg = f"Permission denied for Gemini API. Please check your API key permissions.\nError: {error_msg}"
85 |         else:
86 |             msg = f"Failed to validate Gemini API key. Please check your network connection and API key.\nError: {error_msg}"
   |                                                                                                               ^^^^^^^^^^^^^^^
87 |         raise ValueError(msg) from e
   |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/llm/providers/google_batch.py:215:7
    |
213 |         return results
214 |
215 |     # TODO: [Taskmaster] Refactor for clarity and conciseness
    |       ^^^^
216 |     def _response_to_dict(self, response: Any) -> dict[str, Any]:
217 |         """Convert SDK response object to dict format."""
    |

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/llm/providers/model_cycler.py:145:17
    |
143 |                 self.next_key()
144 |
145 |                 return result
    |                 ^^^^^^^^^^^^^
146 |             except Exception as exc:
147 |                 # Always rotate on error too
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/llm/providers/model_cycler.py:206:11
    |
205 |     def next_model(self) -> str | None:
206 |         # TODO: [Taskmaster] Refactor duplicated rotation logic
    |           ^^^^
207 |         """Advance to the next model in rotation.
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/llm/providers/model_cycler.py:240:11
    |
238 |         is_rate_limit_error: Callable[[Exception], bool] | None = None,
239 |     ) -> Any:
240 |         # TODO: [Taskmaster] Unify state management with GeminiKeyRotator
    |           ^^^^
241 |         """Call a function with automatic model rotation on rate limit errors.
    |

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/llm/providers/model_cycler.py:267:17
    |
265 |                 # Success - reset for next call
266 |                 self.reset()
267 |                 return result
    |                 ^^^^^^^^^^^^^
268 |             except Exception as exc:
269 |                 if is_rate_limit_error(exc):
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/llm/providers/model_key_rotator.py:105:11
    |
103 |         is_rate_limit_error: Callable[[Exception], bool] | None = None,
104 |     ) -> Any:
105 |         # TODO: [Taskmaster] Refactor for clarity and simplified logic
    |           ^^^^
106 |         """Call function trying all keys for each model before rotating models.
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/llm/providers/model_key_rotator.py:122:11
    |
120 |             is_rate_limit_error = default_rate_limit_check
121 |
122 |         # TODO: [Taskmaster] Refactor complex `call_with_rotation` method
    |           ^^^^
123 |         # This method is too long and has a high cyclomatic complexity.
124 |         # It should be broken down into smaller, more manageable functions
    |

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/llm/providers/model_key_rotator.py:137:17
    |
135 |                 result = call_fn(model, api_key)
136 |                 self.reset()
137 |                 return result
    |                 ^^^^^^^^^^^^^
138 |             except Exception as exc:
139 |                 last_exception = exc
    |

FIX002 Line contains TODO, consider resolving the issue
  --> src/egregora/llm/providers/rate_limited.py:38:11
   |
36 |         # Acquire slot (blocks if needed)
37 |         # Note: limiter.acquire() is blocking (sync).
38 |         # TODO: [Taskmaster] Clarify async execution comments
   |           ^^^^
39 |         # The comments below are confusing and outdated. They discuss a move
40 |         # to synchronous execution that may or may not be complete.
   |

FIX002 Line contains TODO, consider resolving the issue
  --> src/egregora/llm/providers/rate_limited.py:47:11
   |
45 |         # Blocking here is fine.
46 |
47 |         # TODO: [Taskmaster] Refactor to safely handle blocking call in async method
   |           ^^^^
48 |         # TODO: [Taskmaster] Refactor to use a try...finally block for consistency
49 |         # The current implementation is inconsistent with `request_stream`.
   |

FIX002 Line contains TODO, consider resolving the issue
  --> src/egregora/llm/providers/rate_limited.py:48:11
   |
47 |         # TODO: [Taskmaster] Refactor to safely handle blocking call in async method
48 |         # TODO: [Taskmaster] Refactor to use a try...finally block for consistency
   |           ^^^^
49 |         # The current implementation is inconsistent with `request_stream`.
50 |         # It should acquire the limiter and then use a `try...finally`
   |

BLE001 Do not catch blind exception: `Exception`
   --> src/egregora/ops/taxonomy.py:141:16
    |
139 |             result = agent.run_sync(prompt)
140 |             batch_results.append(result.data.mappings)
141 |         except Exception as e:
    |                ^^^^^^^^^
142 |             logger.warning("Batch taxonomy generation failed: %s", e)
143 |             batch_results.append([])
    |

ERA001 Found commented-out code
   --> src/egregora/orchestration/context.py:140:5
    |
138 |     cache: PipelineCache
139 |
140 |     # Stores (Optional)
    |     ^^^^^^^^^^^^^^^^^^^
141 |     annotations_store: AnnotationStore | None = None
142 |     task_store: TaskStore | None = None
    |
help: Remove commented-out code

TRY300 Consider moving this statement to an `else` block
  --> src/egregora/orchestration/journal.py:41:9
   |
39 |                 logger.debug("Found existing JOURNAL for signature: %s", signature[:12])
40 |                 return True
41 |         return False
   |         ^^^^^^^^^^^^
42 |     except Exception as e:
43 |         logger.warning("Error checking for existing JOURNAL: %s. Assuming not processed.", e)
   |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/pipelines/write.py:140:3
    |
140 | # TODO: [Taskmaster] Refactor API key validation for clarity and separation of concerns
    |   ^^^^
141 | def _validate_api_key(output_dir: Path) -> None:
142 |     """Validate that API key is set and valid."""
    |

TRY300 Consider moving this statement to an `else` block
   --> src/egregora/orchestration/pipelines/write.py:177:13
    |
175 |                 os.environ["GOOGLE_API_KEY"] = key
176 |             console.print("[green]âœ“ API key validated successfully[/green]")
177 |             return
    |             ^^^^^^
178 |         except ValueError as e:
179 |             validation_errors.append(str(e))
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/pipelines/write.py:304:3
    |
304 | # TODO: [Taskmaster] Refactor validation logic into separate functions
    |   ^^^^
305 | def run_cli_flow(
306 |     input_file: Path,
    |

E501 Line too long (247 > 110)
   --> src/egregora/orchestration/pipelines/write.py:419:111
    |
417 | â€¦
418 | â€¦
419 | â€¦_options.input_file}\n[cyan]Output:[/cyan] {output_dir}\n[cyan]Windowing:[/cyan] {parsed_options.step_size} {parsed_options.step_unit.value}",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
420 | â€¦
421 | â€¦
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/pipelines/write.py:595:7
    |
593 |     max_tokens = full_context_window_size if use_full_window else config.pipeline.max_prompt_tokens
594 |
595 |     # TODO: [Taskmaster] Externalize hardcoded configuration values.
    |       ^^^^
596 |     avg_tokens_per_message = 5
597 |     buffer_ratio = 0.8
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/orchestration/pipelines/write.py:673:72
    |
671 |                     output_sink.persist(media_doc)
672 |                 except Exception as e:
673 |                     logger.exception("Failed to write media file: %s", e)
    |                                                                        ^
674 |
675 |         # ETL Step 2: Enrichment
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/orchestration/pipelines/write.py:732:73
    |
730 |                 announcements_generated += 1
731 |             except Exception as exc:
732 |                 logger.exception("Failed to generate announcement: %s", exc)
    |                                                                         ^^^
733 |
734 |     clean_messages_list = filter_commands(messages_list)
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/orchestration/pipelines/write.py:782:64
    |
780 |                 output_sink.persist(post)
781 |             except Exception as exc:
782 |                 logger.exception("Failed to persist post: %s", exc)
    |                                                                ^^^
783 |
784 |     # EXECUTE PROFILE GENERATOR
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/orchestration/pipelines/write.py:793:67
    |
791 |                 profiles.append(profile_doc.document_id)
792 |             except Exception as exc:
793 |                 logger.exception("Failed to persist profile: %s", exc)
    |                                                                   ^^^
794 |     except Exception as exc:
795 |         logger.exception("Failed to generate profile posts: %s", exc)
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/orchestration/pipelines/write.py:795:66
    |
793 |                 logger.exception("Failed to persist profile: %s", exc)
794 |     except Exception as exc:
795 |         logger.exception("Failed to generate profile posts: %s", exc)
    |                                                                  ^^^
796 |
797 |     # Process background tasks (Banner, etc)
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/pipelines/write.py:833:3
    |
833 | # TODO: [Taskmaster] Simplify database backend creation
    |   ^^^^
834 | def _create_database_backend(
835 |     site_root: Path,
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/pipelines/write.py:879:7
    |
878 | def _create_gemini_client() -> genai.Client:
879 |     # TODO: [Taskmaster] Refactor hardcoded retry logic to be configurable
    |       ^^^^
880 |     """Create a Gemini client with retry configuration.
    |

ERA001 Found commented-out code
    --> src/egregora/orchestration/pipelines/write.py:1237:5
     |
1236 |     # Media RAG indexing removed - will be reimplemented with egregora.rag
1237 |     # logger.info("[bold cyan]ðŸ“š Indexing media into RAG...[/]")
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1238 |     # ... (removed for now)
     |
help: Remove commented-out code

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/runner.py:149:11
    |
147 |         """Calculate maximum window size based on LLM context window."""
148 |         max_tokens = self._resolve_context_token_limit()
149 |         # TODO: [Taskmaster] Externalize hardcoded configuration values.
    |           ^^^^
150 |         avg_tokens_per_message = 5
151 |         buffer_ratio = 0.8
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/runner.py:159:11
    |
157 |         use_full_window = getattr(config.pipeline, "use_full_context_window", False)
158 |
159 |         # TODO: [Taskmaster] Refactor magic number for token limit
    |           ^^^^
160 |         if use_full_window:
161 |             return self.FULL_CONTEXT_WINDOW_SIZE
    |

ERA001 Found commented-out code
   --> src/egregora/orchestration/runner.py:190:17
    |
189 |             for journal in journals:
190 |                 # journal is DocumentMetadata (identifier, doc_type, metadata)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
191 |                 meta = journal.metadata
192 |                 if not meta:
    |
help: Remove commented-out code

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/runner.py:212:11
    |
210 |             return
211 |
212 |         # TODO: [Taskmaster] Refactor worker logic to be more generic
    |           ^^^^
213 |         logger.info("âš™ï¸  [bold cyan]Processing background tasks...[/]")
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/runner.py:273:11
    |
272 |     def _process_single_window(self, window: Window, *, depth: int = 0) -> dict[str, dict[str, list[str]]]:
273 |         # TODO: [Taskmaster] Refactor this method to reduce its complexity.
    |           ^^^^
274 |         # TODO: [Taskmaster] Decompose _process_single_window method
275 |         """Process a single window with media extraction, enrichment, and post writing."""
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/runner.py:274:11
    |
272 |     def _process_single_window(self, window: Window, *, depth: int = 0) -> dict[str, dict[str, list[str]]]:
273 |         # TODO: [Taskmaster] Refactor this method to reduce its complexity.
274 |         # TODO: [Taskmaster] Decompose _process_single_window method
    |           ^^^^
275 |         """Process a single window with media extraction, enrichment, and post writing."""
276 |         indent = "  " * depth
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/orchestration/runner.py:317:72
    |
315 |                     output_sink.persist(media_doc)
316 |                 except Exception as e:
317 |                     logger.exception("Failed to write media file: %s", e)
    |                                                                        ^
318 |
319 |         if self.context.enable_enrichment:
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/runner.py:327:11
    |
325 |         adapter_summary, adapter_instructions = self._extract_adapter_info()
326 |
327 |         # TODO: [Taskmaster] Refactor data type conversion for consistency
    |           ^^^^
328 |         # TODO: [Taskmaster] Improve brittle data conversion logic.
329 |         # Convert table to list for command processing
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/runner.py:328:11
    |
327 |         # TODO: [Taskmaster] Refactor data type conversion for consistency
328 |         # TODO: [Taskmaster] Improve brittle data conversion logic.
    |           ^^^^
329 |         # Convert table to list for command processing
330 |         try:
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/orchestration/runner.py:376:77
    |
374 |                     announcements_generated += 1
375 |                 except Exception as exc:
376 |                     logger.exception("Failed to generate announcement: %s", exc)
    |                                                                             ^^^
377 |
378 |         clean_messages_list = filter_commands(messages_list)
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/orchestration/runner.py:406:71
    |
404 |                     profiles.append(profile_doc.document_id)
405 |                 except Exception as exc:
406 |                     logger.exception("Failed to persist profile: %s", exc)
    |                                                                       ^^^
407 |         except Exception as exc:
408 |             logger.exception("Failed to generate profile posts: %s", exc)
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/orchestration/runner.py:408:70
    |
406 |                     logger.exception("Failed to persist profile: %s", exc)
407 |         except Exception as exc:
408 |             logger.exception("Failed to generate profile posts: %s", exc)
    |                                                                      ^^^
409 |
410 |         # Scheduled tasks are returned as "pending:<task_id>"
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/runner.py:506:7
    |
504 |         return str(summary or "").strip(), str(instructions or "").strip()
505 |
506 |     # TODO: [Taskmaster] Extract command processing logic from _process_single_window
    |       ^^^^
507 |     def _process_commands(self, messages_list: list[dict], output_sink: Any) -> int:
508 |         """Processes commands from a list of messages."""
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/orchestration/runner.py:518:77
    |
516 |                     announcements_generated += 1
517 |                 except Exception as exc:
518 |                     logger.exception("Failed to generate announcement: %s", exc)
    |                                                                             ^^^
519 |         return announcements_generated
    |

FIX002 Line contains TODO, consider resolving the issue
   --> src/egregora/orchestration/runner.py:521:7
    |
519 |         return announcements_generated
520 |
521 |     # TODO: [Taskmaster] Extract status message generation from _process_single_window
    |       ^^^^
522 |     def _construct_status_message(self, posts: list, profiles: list, announcements_generated: int) -> str:
523 |         """Constructs a status message for logging."""
    |

DTZ011 `datetime.date.today()` used
   --> src/egregora/output_adapters/base.py:193:20
    |
191 |         """Extract clean YYYY-MM-DD date from various formats."""
192 |         if not date_str:
193 |             return datetime.date.today().isoformat()
    |                    ^^^^^^^^^^^^^^^^^^^^^
194 |
195 |         date_str = date_str.strip()
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

DTZ011 `datetime.date.today()` used
   --> src/egregora/output_adapters/base.py:218:16
    |
217 |         # Fallback: use today's date
218 |         return datetime.date.today().isoformat()
    |                ^^^^^^^^^^^^^^^^^^^^^
219 |
220 |     @staticmethod
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

ERA001 Found commented-out code
   --> src/egregora/output_adapters/mkdocs/adapter.py:284:17
    |
282 |         match doc_type:
283 |             case DocumentType.PROFILE:
284 |                 # Profiles: "author_uuid/slug" (preferred) or "author_uuid" (latest)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
285 |                 if "/" in identifier:
286 |                     author_uuid, slug = identifier.split("/", 1)
    |
help: Remove commented-out code

E501 Line too long (117 > 110)
   --> src/egregora/rag/embedding_router.py:257:111
    |
255 | â€¦                     # But since we are the only consumer, we can just process what we have
256 | â€¦                     # and put the extra one back? No, LIFO is not guaranteed.
257 | â€¦                     # Better strategy: peek or just accept we might process slightly less optimal batches
    |                                                                                                     ^^^^^^^
258 | â€¦                     # if we have to put it back.
259 | â€¦                     # Actually, standard Queue is FIFO. Putting back goes to end.
    |

E501 Line too long (113 > 110)
   --> src/egregora/rag/embedding_router.py:263:111
    |
261 | â€¦                     # Correct approach: Don't fetch if we can't fit?
262 | â€¦                     # But we don't know size until we fetch.
263 | â€¦                     # Workaround: Put it back and accept reordering, OR use a deque for local buffer.
    |                                                                                                     ^^^
264 | â€¦                     # For simplicity, let's just put it back. Reordering within milliseconds is fine.
265 | â€¦                     self.queue.put(req)
    |

E501 Line too long (113 > 110)
   --> src/egregora/rag/embedding_router.py:264:111
    |
262 | â€¦                     # But we don't know size until we fetch.
263 | â€¦                     # Workaround: Put it back and accept reordering, OR use a deque for local buffer.
264 | â€¦                     # For simplicity, let's just put it back. Reordering within milliseconds is fine.
    |                                                                                                     ^^^
265 | â€¦                     self.queue.put(req)
266 | â€¦                     break
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> src/egregora/rag/lancedb_backend.py:313:64
    |
311 |             return len(document_ids)
312 |         except Exception as e:
313 |             logger.exception("Failed to delete documents: %s", e)
    |                                                                ^
314 |             msg = f"Delete failed: {e}"
315 |             raise RuntimeError(msg) from e
    |

E501 Line too long (111 > 110)
  --> src/egregora/security/zip.py:41:111
   |
39 |         self.max_member_size = max_member_size
40 |         super().__init__(
41 |             f"ZIP member '{member_name}' ({member_size} bytes) exceeds maximum size of {max_member_size} bytes"
   |                                                                                                               ^
42 |         )
   |

SIM108 Use ternary operator `delta = timedelta(hours=step_size) if step_unit == "hours" else timedelta(days=step_size)` instead of `if`-`else`-block
   --> src/egregora/transformations/windowing.py:337:5
    |
336 |       # Calculate window duration
337 | /     if step_unit == "hours":
338 | |         delta = timedelta(hours=step_size)
339 | |     else:  # days
340 | |         delta = timedelta(days=step_size)
    | |_________________________________________^
341 |
342 |       # Calculate overlap duration
    |
help: Replace `if`-`else`-block with `delta = timedelta(hours=step_size) if step_unit == "hours" else timedelta(days=step_size)`

E501 Line too long (196 > 110)
  --> tests/e2e/cli/test_show_command.py:96:111
   |
94 | â€¦
95 | â€¦
96 | â€¦arisons INTEGER, wins INTEGER, losses INTEGER, draws INTEGER, last_compared TIMESTAMP, created_at TIMESTAMP)"
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
97 | â€¦
98 | â€¦
   |

E501 Line too long (118 > 110)
   --> tests/e2e/cli/test_show_command.py:99:111
    |
 97 |     )
 98 |     storage.execute_query(
 99 |         "INSERT INTO elo_ratings VALUES (?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?)",
    |                                                                                                               ^^^^^^^^
100 |         [item for sublist in mock_data for item in sublist],
101 |     )
    |

E501 Line too long (259 > 110)
   --> tests/e2e/cli/test_show_command.py:126:111
    |
124 | â€¦
125 | â€¦
126 | â€¦HAR, winner VARCHAR, rating_a_before DOUBLE, rating_b_before DOUBLE, rating_a_after DOUBLE, rating_b_after DOUBLE, timestamp TIMESTAMP, metadata VARCHAR)"
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
127 | â€¦
128 | â€¦
    |

E501 Line too long (111 > 110)
   --> tests/e2e/cli/test_show_command.py:129:111
    |
127 |     )
128 |     storage.execute_query(
129 |         "INSERT INTO comparison_history VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
    |                                                                                                               ^
130 |         [item for sublist in mock_data for item in sublist],
131 |     )
    |

TRY002 Create your own exception
  --> tests/step_defs/test_model_key_rotation.py:56:19
   |
54 |         if context["call_count"] <= 8:
55 |             msg = "429 Too Many Requests"
56 |             raise Exception(msg)
   |                   ^^^^^^^^^^^^^^
57 |
58 |         return f"Success with {model} and {api_key}"
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> tests/unit/agents/test_avatar.py:35:23
   |
33 |             value="http://example.com/avatar.jpg",
34 |             author_uuid="author1",
35 |             timestamp=datetime.now(),
   |                       ^^^^^^^^^^^^^^
36 |             context=context,
37 |         )
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> tests/unit/agents/test_avatar.py:57:23
   |
55 |         result = _process_set_avatar_command(
56 |             author_uuid="author1",
57 |             timestamp=datetime.now(),
   |                       ^^^^^^^^^^^^^^
58 |             context=context,
59 |             value="http://example.com/new_avatar.jpg",
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

E501 Line too long (118 > 110)
  --> tests/unit/agents/test_writer_error_handling.py:26:111
   |
24 | @patch("egregora.agents.writer.get_google_api_keys", return_value=["key1", "key2"])
25 | @patch("egregora.agents.writer._get_openrouter_free_models", return_value=[])
26 | def test_writer_rotates_keys_on_failure(mock_free_models, mock_google_keys, mock_write_posts, mock_config, mock_deps):
   |                                                                                                               ^^^^^^^^
27 |     mock_write_posts.side_effect = [
28 |         ModelHTTPError(body={"message": "Rate limit exceeded"}, status_code=429),
   |

E501 Line too long (127 > 110)
  --> tests/unit/agents/test_writer_error_handling.py:43:111
   |
41 | @patch("egregora.agents.writer.write_posts_with_pydantic_agent")
42 | @patch("egregora.agents.writer.get_google_api_keys", return_value=["key1"])
43 | @patch("egregora.agents.writer._iter_writer_models", return_value=["google-gla:gemini-1.5-flash", "google-gla:gemini-1.0-pro"])
   |                                                                                                               ^^^^^^^^^^^^^^^^^
44 | def test_writer_rotates_models_on_persistent_failure(mock_iter_models, mock_google_keys, mock_write_posts, mock_config, mock_deps):
45 |     mock_write_posts.side_effect = [
   |

E501 Line too long (131 > 110)
  --> tests/unit/agents/test_writer_error_handling.py:44:111
   |
42 | @patch("egregora.agents.writer.get_google_api_keys", return_value=["key1"])
43 | @patch("egregora.agents.writer._iter_writer_models", return_value=["google-gla:gemini-1.5-flash", "google-gla:gemini-1.0-pro"])
44 | def test_writer_rotates_models_on_persistent_failure(mock_iter_models, mock_google_keys, mock_write_posts, mock_config, mock_deps):
   |                                                                                                               ^^^^^^^^^^^^^^^^^^^^^
45 |     mock_write_posts.side_effect = [
46 |         ModelHTTPError(body={"message": "Internal Server Error"}, status_code=500),
   |

E501 Line too long (125 > 110)
  --> tests/unit/agents/test_writer_error_handling.py:61:111
   |
59 | @patch("egregora.agents.writer.get_google_api_keys", return_value=["key1", "key2"])
60 | @patch("egregora.agents.writer._iter_writer_models", return_value=["google-gla:gemini-1.5-flash"])
61 | def test_writer_exhausts_all_retries_and_fails(mock_iter_models, mock_google_keys, mock_write_posts, mock_config, mock_deps):
   |                                                                                                               ^^^^^^^^^^^^^^^
62 |     mock_write_posts.side_effect = ModelHTTPError(body={"message": "Internal Server Error"}, status_code=500)
   |

E501 Line too long (116 > 110)
  --> tests/unit/agents/test_writer_error_handling.py:72:111
   |
70 | @patch("egregora.agents.writer.get_google_api_keys", return_value=["key1"])
71 | @patch("egregora.agents.writer._iter_writer_models", return_value=["google-gla:gemini-1.5-flash"])
72 | def test_writer_succeeds_on_first_try(mock_iter_models, mock_google_keys, mock_write_posts, mock_config, mock_deps):
   |                                                                                                               ^^^^^^
73 |     mock_write_posts.return_value = ("posts", "profiles")
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> tests/unit/agents/test_writer_logic.py:58:92
   |
57 |         # We need at least one entry for save to happen
58 |         entry = writer_module.JournalEntry(entry_type="journal", content="test", timestamp=datetime.now())
   |                                                                                            ^^^^^^^^^^^^^^
59 |
60 |         params = writer_module.WriterJournalEntryParams(
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> tests/unit/agents/test_writer_logic.py:66:26
   |
64 |             posts_published=0,
65 |             profiles_updated=0,
66 |             window_start=datetime.now(),
   |                          ^^^^^^^^^^^^^^
67 |             window_end=datetime.now(),
68 |         )
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> tests/unit/agents/test_writer_logic.py:67:24
   |
65 |             profiles_updated=0,
66 |             window_start=datetime.now(),
67 |             window_end=datetime.now(),
   |                        ^^^^^^^^^^^^^^
68 |         )
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> tests/unit/agents/test_writer_logic.py:91:77
   |
90 |         params = writer_module.WriterJournalEntryParams(
91 |             intercalated_log=[writer_module.JournalEntry("journal", "test", datetime.now())],
   |                                                                             ^^^^^^^^^^^^^^
92 |             window_label="test-window",
93 |             output_sink=MagicMock(),
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> tests/unit/agents/test_writer_logic.py:96:26
   |
94 |             posts_published=0,
95 |             profiles_updated=0,
96 |             window_start=datetime.now(),
   |                          ^^^^^^^^^^^^^^
97 |             window_end=datetime.now(),
98 |         )
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> tests/unit/agents/test_writer_logic.py:97:24
   |
95 |             profiles_updated=0,
96 |             window_start=datetime.now(),
97 |             window_end=datetime.now(),
   |                        ^^^^^^^^^^^^^^
98 |         )
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> tests/unit/agents/test_writer_logic.py:120:77
    |
119 |         params = writer_module.WriterJournalEntryParams(
120 |             intercalated_log=[writer_module.JournalEntry("journal", "test", datetime.now())],
    |                                                                             ^^^^^^^^^^^^^^
121 |             window_label="test-window",
122 |             output_sink=mock_output,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> tests/unit/agents/test_writer_logic.py:125:26
    |
123 |             posts_published=0,
124 |             profiles_updated=0,
125 |             window_start=datetime.now(),
    |                          ^^^^^^^^^^^^^^
126 |             window_end=datetime.now(),
127 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> tests/unit/agents/test_writer_logic.py:126:24
    |
124 |             profiles_updated=0,
125 |             window_start=datetime.now(),
126 |             window_end=datetime.now(),
    |                        ^^^^^^^^^^^^^^
127 |         )
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> tests/unit/agents/test_writer_logic.py:183:22
    |
181 |     params = writer_module.WindowProcessingParams(
182 |         table=mock_table,
183 |         window_start=datetime.now(),
    |                      ^^^^^^^^^^^^^^
184 |         window_end=datetime.now(),
185 |         resources=MagicMock(),
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> tests/unit/agents/test_writer_logic.py:184:20
    |
182 |         table=mock_table,
183 |         window_start=datetime.now(),
184 |         window_end=datetime.now(),
    |                    ^^^^^^^^^^^^^^
185 |         resources=MagicMock(),
186 |         config=test_config,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> tests/unit/agents/test_writer_logic.py:258:12
    |
256 |     mock_message = Message(
257 |         event_id="test-id",
258 |         ts=datetime.now(),
    |            ^^^^^^^^^^^^^^
259 |         author_uuid="test-author",
260 |         text="test content",
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> tests/unit/agents/test_writer_logic.py:267:22
    |
265 |     params = writer_module.WindowProcessingParams(
266 |         table=mock_table,
267 |         window_start=datetime.now(),
    |                      ^^^^^^^^^^^^^^
268 |         window_end=datetime.now(),
269 |         resources=mock_resources,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> tests/unit/agents/test_writer_logic.py:268:20
    |
266 |         table=mock_table,
267 |         window_start=datetime.now(),
268 |         window_end=datetime.now(),
    |                    ^^^^^^^^^^^^^^
269 |         resources=mock_resources,
270 |         config=test_config,
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
  --> tests/unit/common/test_datetime_utils.py:20:22
   |
18 |     "iso_datetime_zulu": ("2025-01-01T12:00:00Z", datetime(2025, 1, 1, 12, 0, 0, tzinfo=UTC)),
19 |     "human_date": ("Jan 1, 2025", datetime(2025, 1, 1, tzinfo=UTC)),
20 |     "datetime_obj": (datetime(2025, 1, 1, 12, 0, 0), datetime(2025, 1, 1, 12, 0, 0, tzinfo=UTC)),
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
21 |     "date_obj": (date(2025, 1, 1), datetime(2025, 1, 1, tzinfo=UTC)),
22 |     "time_only": (
   |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

ERA001 Found commented-out code
  --> tests/unit/dev_tools/test_check_private_imports.py:8:1
   |
 6 | # Add scripts/dev_tools to path
 7 | # We are in tests/unit/dev_tools/test_check_private_imports.py
 8 | # parents[0] = dev_tools
   | ^^^^^^^^^^^^^^^^^^^^^^^^
 9 | # parents[1] = unit
10 | # parents[2] = tests
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> tests/unit/dev_tools/test_check_private_imports.py:9:1
   |
 7 | # We are in tests/unit/dev_tools/test_check_private_imports.py
 8 | # parents[0] = dev_tools
 9 | # parents[1] = unit
   | ^^^^^^^^^^^^^^^^^^^
10 | # parents[2] = tests
11 | # parents[3] = root
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> tests/unit/dev_tools/test_check_private_imports.py:10:1
   |
 8 | # parents[0] = dev_tools
 9 | # parents[1] = unit
10 | # parents[2] = tests
   | ^^^^^^^^^^^^^^^^^^^^
11 | # parents[3] = root
12 | sys.path.insert(0, str(Path(__file__).parents[3] / "scripts" / "dev_tools"))
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> tests/unit/dev_tools/test_check_private_imports.py:11:1
   |
 9 | # parents[1] = unit
10 | # parents[2] = tests
11 | # parents[3] = root
   | ^^^^^^^^^^^^^^^^^^^
12 | sys.path.insert(0, str(Path(__file__).parents[3] / "scripts" / "dev_tools"))
   |
help: Remove commented-out code

E501 Line too long (134 > 110)
  --> tests/unit/input_adapters/whatsapp/test_parsing_perf.py:37:111
   |
35 |     # A larger block of text with sparsely distributed PII to better simulate a real chat log.
36 |     lorem_ipsum = (
37 |         "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. "
   |                                                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^
38 |         * 20
39 |     )
   |

E501 Line too long (139 > 110)
  --> tests/unit/input_adapters/whatsapp/test_parsing_perf.py:40:111
   |
38 | â€¦
39 | â€¦
40 | â€¦st@example.com. {lorem_ipsum} Or call (123) 456-7890. {lorem_ipsum} End of text."
   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
41 | â€¦
   |

PT012 `pytest.raises()` block should contain a single simple statement
  --> tests/unit/knowledge/test_profiles_exceptions.py:19:5
   |
17 |       """Test that ProfileNotFoundError sets author_uuid correctly."""
18 |       author_uuid = "test-uuid"
19 | /     with pytest.raises(ProfileNotFoundError) as excinfo:
20 | |         msg = "Profile not found"
21 | |         raise ProfileNotFoundError(msg, author_uuid=author_uuid)
   | |________________________________________________________________^
22 |       assert excinfo.value.author_uuid == author_uuid
23 |       assert excinfo.value.path is None
   |

PT012 `pytest.raises()` block should contain a single simple statement
  --> tests/unit/knowledge/test_profiles_exceptions.py:29:5
   |
27 |       """Test that ProfileNotFoundError sets path correctly."""
28 |       path = "/test/path"
29 | /     with pytest.raises(ProfileNotFoundError) as excinfo:
30 | |         msg = "Profile not found"
31 | |         raise ProfileNotFoundError(msg, path=path)
   | |__________________________________________________^
32 |       assert excinfo.value.path == path
33 |       assert excinfo.value.author_uuid is None
   |

PT012 `pytest.raises()` block should contain a single simple statement
  --> tests/unit/knowledge/test_profiles_exceptions.py:39:5
   |
37 |       """Test that ProfileParseError sets path correctly."""
38 |       path = "/test/path"
39 | /     with pytest.raises(ProfileParseError) as excinfo:
40 | |         msg = "Parse error"
41 | |         raise ProfileParseError(msg, path=path)
   | |_______________________________________________^
42 |       assert excinfo.value.path == path
   |

PT012 `pytest.raises()` block should contain a single simple statement
  --> tests/unit/knowledge/test_profiles_exceptions.py:48:5
   |
46 |       """Test that InvalidAliasError sets alias correctly."""
47 |       alias = "test-alias"
48 | /     with pytest.raises(InvalidAliasError) as excinfo:
49 | |         msg = "Invalid alias"
50 | |         raise InvalidAliasError(msg, alias=alias)
   | |_________________________________________________^
51 |       assert excinfo.value.alias == alias
   |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> tests/unit/orchestration/test_factory.py:24:20
   |
22 |     return PipelineRunParams(
23 |         run_id="test-run",
24 |         start_time=datetime.now(),
   |                    ^^^^^^^^^^^^^^
25 |         source_type="test",
26 |         config=config,
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
  --> tests/unit/orchestration/test_runner.py:41:25
   |
39 |     window.size = 10
40 |     # Use real datetime objects to avoid formatting issues
41 |     window.start_time = datetime(2023, 1, 1, 10, 0)
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
42 |     window.end_time = datetime(2023, 1, 2, 10, 0)
43 |     window.window_index = 0
   |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
  --> tests/unit/orchestration/test_runner.py:42:23
   |
40 |     # Use real datetime objects to avoid formatting issues
41 |     window.start_time = datetime(2023, 1, 1, 10, 0)
42 |     window.end_time = datetime(2023, 1, 2, 10, 0)
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
43 |     window.window_index = 0
   |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
  --> tests/unit/orchestration/test_runner.py:56:22
   |
54 |     results, max_ts = runner.process_windows(windows_iterator)
55 |     assert results == {"test_window": {"posts": ["post1"]}}
56 |     assert max_ts == datetime(2023, 1, 2, 10, 0)
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
57 |
58 |     runner.process_background_tasks.assert_called()
   |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
  --> tests/unit/orchestration/test_runner.py:88:25
   |
87 |     window = MagicMock()
88 |     window.start_time = datetime(2023, 1, 1)
   |                         ^^^^^^^^^^^^^^^^^^^^
89 |     window.end_time = datetime(2023, 1, 1, 1)
90 |     window.table = MagicMock()
   |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
  --> tests/unit/orchestration/test_runner.py:89:23
   |
87 |     window = MagicMock()
88 |     window.start_time = datetime(2023, 1, 1)
89 |     window.end_time = datetime(2023, 1, 1, 1)
   |                       ^^^^^^^^^^^^^^^^^^^^^^^
90 |     window.table = MagicMock()
91 |     window.size = 10
   |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   --> tests/unit/orchestration/test_runner.py:157:36
    |
155 |     # Mock the split function to return a dummy window to continue the loop
156 |     mock_split_window = MagicMock()
157 |     mock_split_window.start_time = datetime(2023, 1, 1, 12, 0)
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
158 |     mock_split_window.end_time = datetime(2023, 1, 1, 13, 0)
159 |     mock_split_window.size = 5  # Needs to be greater than or equal to min_window_size in the code
    |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   --> tests/unit/orchestration/test_runner.py:158:34
    |
156 |     mock_split_window = MagicMock()
157 |     mock_split_window.start_time = datetime(2023, 1, 1, 12, 0)
158 |     mock_split_window.end_time = datetime(2023, 1, 1, 13, 0)
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
159 |     mock_split_window.size = 5  # Needs to be greater than or equal to min_window_size in the code
160 |     monkeypatch.setattr(
    |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   --> tests/unit/orchestration/test_runner.py:165:30
    |
164 |     mock_window = MagicMock()
165 |     mock_window.start_time = datetime(2023, 1, 1, 12, 0)
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
166 |     mock_window.end_time = datetime(2023, 1, 1, 13, 0)
167 |     mock_window.size = 10
    |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   --> tests/unit/orchestration/test_runner.py:166:28
    |
164 |     mock_window = MagicMock()
165 |     mock_window.start_time = datetime(2023, 1, 1, 12, 0)
166 |     mock_window.end_time = datetime(2023, 1, 1, 13, 0)
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
167 |     mock_window.size = 10
    |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   --> tests/unit/orchestration/test_runner.py:183:30
    |
182 |     mock_window = MagicMock()
183 |     mock_window.start_time = datetime(2023, 1, 1, 12, 0)
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
184 |     mock_window.end_time = datetime(2023, 1, 1, 13, 0)
185 |     mock_window.size = 10
    |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   --> tests/unit/orchestration/test_runner.py:184:28
    |
182 |     mock_window = MagicMock()
183 |     mock_window.start_time = datetime(2023, 1, 1, 12, 0)
184 |     mock_window.end_time = datetime(2023, 1, 1, 13, 0)
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
185 |     mock_window.size = 10
    |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
  --> tests/unit/orchestration/test_runner_journal.py:52:26
   |
50 |     # Window 1: Matches journal -> Should be skipped
51 |     window1 = MagicMock()
52 |     window1.start_time = datetime(2023, 1, 1, 10, 0, 0)
   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
53 |     window1.end_time = datetime(2023, 1, 1, 12, 0, 0)
54 |     window1.window_index = 0
   |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
  --> tests/unit/orchestration/test_runner_journal.py:53:24
   |
51 |     window1 = MagicMock()
52 |     window1.start_time = datetime(2023, 1, 1, 10, 0, 0)
53 |     window1.end_time = datetime(2023, 1, 1, 12, 0, 0)
   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
54 |     window1.window_index = 0
55 |     window1.size = 10
   |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
  --> tests/unit/orchestration/test_runner_journal.py:59:26
   |
57 |     # Window 2: New -> Should be processed
58 |     window2 = MagicMock()
59 |     window2.start_time = datetime(2023, 1, 1, 12, 0, 0)
   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
60 |     window2.end_time = datetime(2023, 1, 1, 14, 0, 0)
61 |     window2.window_index = 1
   |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
  --> tests/unit/orchestration/test_runner_journal.py:60:24
   |
58 |     window2 = MagicMock()
59 |     window2.start_time = datetime(2023, 1, 1, 12, 0, 0)
60 |     window2.end_time = datetime(2023, 1, 1, 14, 0, 0)
   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
61 |     window2.window_index = 1
62 |     window2.size = 10
   |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

TRY002 Create your own exception
   --> tests/unit/orchestration/test_runner_journal_integration.py:170:23
    |
168 |             if doc == mock_journal_doc:
169 |                 msg = "DB Error"
170 |                 raise Exception(msg)
    |                       ^^^^^^^^^^^^^^
171 |
172 |         mock_context.output_sink.persist.side_effect = persist_side_effect
    |

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
  --> tests/unit/output_adapters/mkdocs/test_markdown_utils.py:19:31
   |
17 | # region: Tests for extract_clean_date
18 | def test_extract_clean_date_with_datetime():
19 |     assert extract_clean_date(datetime(2023, 1, 1, 12, 30)) == "2023-01-01"
   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
  --> tests/unit/output_adapters/mkdocs/test_markdown_utils.py:60:6
   |
58 |     ("2023-01-15", "2023-01-15"),
59 |     (date(2023, 1, 15), "2023-01-15"),
60 |     (datetime(2023, 1, 15, 10, 30), "2023-01-15"),
   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
61 |     ("  2023-01-15T10:30:00Z  ", "2023-01-15"),
62 |     ("Some text surrounding 2023-01-15 and other things", "2023-01-15"),
   |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

PT012 `pytest.raises()` block should contain a single simple statement
  --> tests/unit/rag/test_exceptions.py:37:9
   |
35 |       def test_can_be_raised_and_caught(self):
36 |           """EmbeddingError can be raised and caught."""
37 | /         with pytest.raises(EmbeddingError) as exc_info:
38 | |             msg = "Embedding failed"
39 | |             raise EmbeddingError(msg)
   | |_____________________________________^
40 |           assert "Embedding failed" in str(exc_info.value)
   |

PT012 `pytest.raises()` block should contain a single simple statement
   --> tests/unit/rag/test_exceptions.py:101:9
    |
 99 |       def test_can_be_caught_as_embedding_error(self):
100 |           """Validation errors can be caught as EmbeddingError."""
101 | /         with pytest.raises(EmbeddingError):
102 | |             msg = "Invalid response format"
103 | |             raise EmbeddingValidationError(msg)
    | |_______________________________________________^
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
  --> tests/unit/rag/test_vectorized_rag.py:33:27
   |
31 |         self.slug = f"mock-slug-{document_id}"
32 |         self.suggested_path = f"posts/{self.slug}.md"
33 |         self.created_at = datetime.now()
   |                           ^^^^^^^^^^^^^^
34 |         self.source_window = "test_window"
35 |         self.metadata = {}
   |
help: Pass a `datetime.timezone` object to the `tz` parameter

ERA001 Found commented-out code
  --> tests/unit/test_media_slugs.py:82:5
   |
81 |     # 2. suggested_path should include the subfolder and slug-based name
82 |     # DESIRED: media/images/cool-new-slug.jpg
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
83 |     # CURRENT: None (or some default if not set)
84 |     assert media_doc.suggested_path == "media/images/cool-new-slug.jpg"
   |
help: Remove commented-out code

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
  --> tests/unit/transformations/test_windowing.py:21:22
   |
19 | def create_test_table(messages=100, start_time=None):
20 |     if start_time is None:
21 |         start_time = datetime(2023, 1, 1, 10, 0, 0)
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 |
23 |     if isinstance(messages, int):
   |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   --> tests/unit/transformations/test_windowing.py:102:13
    |
101 |     # Messages are 1 min apart starting at 10:00:00
102 |     start = datetime(2023, 1, 1, 10, 0, 0)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
103 |     assert w0_min == start
104 |     assert w1_min == start + timedelta(minutes=50)
    |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   --> tests/unit/transformations/test_windowing.py:260:18
    |
258 |     """Test that max_window_time constrains the window size."""
259 |     # 3 days of data (72 hours)
260 |     start_time = datetime(2023, 1, 1, 0, 0, 0)
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
261 |     # One message per hour for 72 hours
262 |     data = [{"ts": start_time + timedelta(hours=i), "text": f"msg {i}", "sender": "A"} for i in range(72)]
    |
help: Pass a `datetime.timezone` object to the `tzinfo` parameter

Found 223 errors.
