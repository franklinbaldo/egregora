import hashlib
import uuid
from datetime import UTC, datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field


# --- Atom Core Domain ---

class Link(BaseModel):
    href: str
    rel: str | None = None        # ex: "alternate", "enclosure", "self"
    type: str | None = None       # ex: "text/html", "image/jpeg"
    hreflang: str | None = None
    title: str | None = None
    length: int | None = None

class Author(BaseModel):
    name: str
    email: str | None = None
    uri: str | None = None

class Category(BaseModel):
    term: str                     # A tag or category
    scheme: str | None = None     # URI of the taxonomy scheme
    label: str | None = None      # Readable label

class Source(BaseModel):
    id: str | None = None
    title: str | None = None
    updated: datetime | None = None
    links: list[Link] = Field(default_factory=list)

class Entry(BaseModel):
    id: str                       # URI or stable unique ID
    title: str
    updated: datetime
    published: datetime | None = None

    links: list[Link] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    contributors: list[Author] = Field(default_factory=list)
    categories: list[Category] = Field(default_factory=list)

    summary: str | None = None    # Short text / Teaser
    content: str | None = None    # Main body (Markdown/HTML)
    content_type: str | None = None # ex: "text/markdown"

    source: Source | None = None

    # Public extensions (Atom compliant)
    extensions: dict[str, Any] = Field(default_factory=dict)

    # Internal system metadata (not serialized to public Atom)
    internal_metadata: dict[str, Any] = Field(default_factory=dict)


# --- Application Domain ---

class DocumentType(str, Enum):
    RECAP = "recap"
    NOTE = "note"
    PLAN = "plan"
    POST = "post"
    MEDIA = "media"
    PROFILE = "profile"

class DocumentStatus(str, Enum):
    DRAFT = "draft"
    PUBLISHED = "published"
    ARCHIVED = "archived"

class Document(Entry):
    """
    Represents an artifact generated by Egregora.
    Inherits from Entry to ensure Atom compatibility.
    """
    doc_type: DocumentType
    status: DocumentStatus = DocumentStatus.DRAFT

    # Suggestion for path for file-based OutputAdapters (MkDocs/Hugo)
    url_path: str | None = None

    @classmethod
    def create(cls,
               content: str,
               doc_type: DocumentType,
               title: str,
               status: DocumentStatus = DocumentStatus.DRAFT,
               internal_metadata: dict[str, Any] | None = None,
               id_override: str | None = None) -> "Document":
        """Factory method to create a Document.

        If id_override is not provided, generates a content-addressed ID (UUIDv5).
        """
        if internal_metadata is None:
            internal_metadata = {}

        if id_override:
            doc_id = id_override
        else:
            # Content-addressed ID based on content + type
            hasher = hashlib.sha256()
            hasher.update(content.encode('utf-8'))
            hasher.update(doc_type.value.encode('utf-8'))
            # We use the hash to generate a UUIDv5
            doc_id = str(uuid.uuid5(uuid.NAMESPACE_DNS, hasher.hexdigest()))

        return cls(
            id=doc_id,
            title=title,
            updated=datetime.now(UTC),
            content=content,
            doc_type=doc_type,
            status=status,
            internal_metadata=internal_metadata,
        )


class Feed(BaseModel):
    id: str
    title: str
    updated: datetime
    entries: list[Entry] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    links: list[Link] = Field(default_factory=list)


def documents_to_feed(
    docs: list[Document],
    feed_id: str,
    title: str,
    authors: list[Author] | None = None,
) -> Feed:
    """Aggregates documents into a valid Atom Feed."""
    if not docs:
        updated = datetime.now(UTC)
    else:
        updated = max(doc.updated for doc in docs)

    return Feed(
        id=feed_id,
        title=title,
        updated=updated,
        authors=authors or [],
        entries=docs
    )
