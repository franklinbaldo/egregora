import hashlib
import uuid
from datetime import UTC, datetime
from enum import Enum
from typing import Any
from xml.etree.ElementTree import Element

from pydantic import BaseModel, Field

from egregora_v3.core.utils import slugify

# --- Atom Core Domain ---


class Link(BaseModel):
    href: str
    rel: str | None = None  # ex: "alternate", "enclosure", "self", "in-reply-to"
    type: str | None = None  # ex: "text/html", "image/jpeg"
    hreflang: str | None = None
    title: str | None = None
    length: int | None = None


class Author(BaseModel):
    name: str
    email: str | None = None
    uri: str | None = None


class Category(BaseModel):
    term: str  # A tag or category
    scheme: str | None = None  # URI of the taxonomy scheme
    label: str | None = None  # Readable label


class Source(BaseModel):
    id: str | None = None
    title: str | None = None
    updated: datetime | None = None
    links: list[Link] = Field(default_factory=list)


class InReplyTo(BaseModel):
    """Atom Threading Extension (RFC 4685)."""

    ref: str  # ID of the parent entry
    href: str | None = None  # Link to the parent entry
    type: str | None = None


class Entry(BaseModel):
    id: str  # URI or stable unique ID
    feed_id: str | None = None
    title: str
    updated: datetime
    published: datetime | None = None

    links: list[Link] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    contributors: list[Author] = Field(default_factory=list)
    categories: list[Category] = Field(default_factory=list)

    summary: str | None = None  # Short text / Teaser
    content: str | None = None  # Main body (Markdown/HTML)
    content_type: str | None = None  # ex: "text/markdown"

    source: Source | None = None

    # Threading (RFC 4685)
    in_reply_to: InReplyTo | None = None

    # Public extensions (Atom compliant)
    extensions: dict[str, Any] = Field(default_factory=dict)

    # Internal system metadata (not serialized to public Atom)
    internal_metadata: dict[str, Any] = Field(default_factory=dict)


# --- Application Domain ---


class DocumentType(str, Enum):
    RECAP = "recap"
    NOTE = "note"
    PLAN = "plan"
    POST = "post"
    MEDIA = "media"
    PROFILE = "profile"
    ENRICHMENT = "enrichment"


class DocumentStatus(str, Enum):
    DRAFT = "draft"
    PUBLISHED = "published"
    ARCHIVED = "archived"


class Document(Entry):
    """Represents an artifact generated by Egregora.

    Inherits from Entry to ensure Atom compatibility.
    """

    doc_type: DocumentType
    status: DocumentStatus = DocumentStatus.DRAFT

    # RAG Indexing Policy
    searchable: bool = True

    # Suggestion for path for file-based OutputAdapters (MkDocs/Hugo)
    url_path: str | None = None

    @property
    def slug(self) -> str | None:
        """Get the semantic slug for this document."""
        return self.internal_metadata.get("slug")

    @classmethod
    def create(  # noqa: PLR0913
        cls,
        content: str,
        doc_type: DocumentType,
        title: str,
        *,
        status: DocumentStatus = DocumentStatus.DRAFT,
        internal_metadata: dict[str, Any] | None = None,
        id_override: str | None = None,
        slug: str | None = None,
        searchable: bool = True,
        in_reply_to: InReplyTo | None = None,
    ) -> "Document":
        """Factory method to create a Document.

        V3 CHANGE: Supports Semantic Identity.
        If `slug` is provided (and type is POST/MEDIA), it acts as the ID.
        If no slug is provided for semantic types, derive it from the title.
        If `id_override` is provided, it acts as the ID.
        Otherwise, generates a content-addressed ID (UUIDv5).
        """
        if internal_metadata is None:
            internal_metadata = {}

        semantic_types = (DocumentType.POST, DocumentType.MEDIA)

        # Derive slug for semantic types only when absent
        if slug is None and doc_type in semantic_types:
            title_for_slug = title.strip()
            if title_for_slug:
                derived_slug = slugify(title_for_slug, max_len=60)
                slug = derived_slug if derived_slug else None

        # Sanitize and persist slug for downstream consumers
        clean_slug: str | None = None
        if slug:
            clean_slug = slugify(slug, max_len=60)
            if clean_slug:
                internal_metadata["slug"] = clean_slug

        # Determine ID
        doc_id = None
        if id_override:
            doc_id = id_override
        elif clean_slug and doc_type in semantic_types:
            # Semantic Identity
            doc_id = clean_slug

        # Fallback to UUIDv5
        if not doc_id:
            hasher = hashlib.sha256()
            hasher.update(content.encode("utf-8"))
            hasher.update(doc_type.value.encode("utf-8"))
            doc_id = str(uuid.uuid5(uuid.NAMESPACE_DNS, hasher.hexdigest()))

        return cls(
            id=doc_id,
            title=title,
            updated=datetime.now(UTC),
            content=content,
            doc_type=doc_type,
            status=status,
            internal_metadata=internal_metadata,
            searchable=searchable,
            in_reply_to=in_reply_to,
        )


class Feed(BaseModel):
    id: str
    title: str
    updated: datetime
    entries: list[Entry] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    links: list[Link] = Field(default_factory=list)

    def to_xml(self) -> str:  # noqa: C901
        """Generate Atom XML feed (RFC 4287 compliant).

        Returns:
            Valid Atom 1.0 XML string

        """
        # Note: Imports are inside method to keep types.py lightweight and free of global side-effects
        # We suppress the lint warning as this is a deliberate design choice for core types.
        from xml.etree.ElementTree import SubElement, tostring  # noqa: PLC0415

        # Create root feed element with Atom namespace
        feed = Element("feed", xmlns="http://www.w3.org/2005/Atom")

        # Required feed elements
        SubElement(feed, "id").text = self.id
        SubElement(feed, "title").text = self.title
        SubElement(feed, "updated").text = self._format_datetime(self.updated)

        # Authors
        for author in self.authors:
            author_elem = SubElement(feed, "author")
            SubElement(author_elem, "name").text = author.name
            if author.email:
                SubElement(author_elem, "email").text = author.email
            if author.uri:
                SubElement(author_elem, "uri").text = author.uri

        # Links
        for link in self.links:
            link_elem = SubElement(feed, "link")
            link_elem.set("href", link.href)
            if link.rel:
                link_elem.set("rel", link.rel)
            if link.type:
                link_elem.set("type", link.type)
            if link.hreflang:
                link_elem.set("hreflang", link.hreflang)
            if link.title:
                link_elem.set("title", link.title)
            if link.length:
                link_elem.set("length", str(link.length))

        # Entries
        for entry in self.entries:
            self._add_entry_to_feed(feed, entry)

        # Convert to string with XML declaration
        xml_bytes = tostring(feed, encoding="utf-8", xml_declaration=True)
        return xml_bytes.decode("utf-8")

    def _add_entry_to_feed(self, feed_elem: Element, entry: Entry) -> None:  # noqa: C901, PLR0912, PLR0915
        """Add an Entry to the feed XML element."""
        from xml.etree.ElementTree import SubElement  # noqa: PLC0415

        entry_elem = SubElement(feed_elem, "entry")

        # Specific Logic for Documents
        if isinstance(entry, Document):
            # Export doc_type as category
            SubElement(
                entry_elem,
                "category",
                {
                    "term": entry.doc_type.value,
                    "scheme": "https://egregora.app/schema#doc_type",
                    "label": "Document Type",
                },
            )
            # Export status as category
            SubElement(
                entry_elem,
                "category",
                {
                    "term": entry.status.value,
                    "scheme": "https://egregora.app/schema#status",
                    "label": "Document Status",
                },
            )

        # Required entry elements
        SubElement(entry_elem, "id").text = entry.id
        SubElement(entry_elem, "title").text = entry.title
        SubElement(entry_elem, "updated").text = self._format_datetime(entry.updated)

        # Optional elements
        if entry.published:
            SubElement(entry_elem, "published").text = self._format_datetime(entry.published)

        if entry.summary:
            SubElement(entry_elem, "summary").text = entry.summary

        if entry.content:
            content_elem = SubElement(entry_elem, "content")
            content_elem.text = entry.content
            if entry.content_type:
                # Normalize content type for Atom
                content_type = entry.content_type
                if content_type == "text/markdown":
                    content_type = "text"
                elif content_type == "text/html":
                    content_type = "html"
                content_elem.set("type", content_type)

        # Authors
        for author in entry.authors:
            author_elem = SubElement(entry_elem, "author")
            SubElement(author_elem, "name").text = author.name
            if author.email:
                SubElement(author_elem, "email").text = author.email
            if author.uri:
                SubElement(author_elem, "uri").text = author.uri

        # Links
        for link in entry.links:
            link_elem = SubElement(entry_elem, "link")
            link_elem.set("href", link.href)
            if link.rel:
                link_elem.set("rel", link.rel)
            if link.type:
                link_elem.set("type", link.type)
            if link.hreflang:
                link_elem.set("hreflang", link.hreflang)
            if link.title:
                link_elem.set("title", link.title)
            if link.length:
                link_elem.set("length", str(link.length))

        # Categories
        for category in entry.categories:
            cat_elem = SubElement(entry_elem, "category")
            cat_elem.set("term", category.term)
            if category.scheme:
                cat_elem.set("scheme", category.scheme)
            if category.label:
                cat_elem.set("label", category.label)

        # Threading (RFC 4685)
        if entry.in_reply_to:
            in_reply_to_elem = SubElement(entry_elem, "{http://purl.org/syndication/thread/1.0}in-reply-to")
            in_reply_to_elem.set("ref", entry.in_reply_to.ref)
            if entry.in_reply_to.href:
                in_reply_to_elem.set("href", entry.in_reply_to.href)
            if entry.in_reply_to.type:
                in_reply_to_elem.set("type", entry.in_reply_to.type)

    @staticmethod
    def _format_datetime(dt: datetime) -> str:
        """Format datetime as RFC 3339 (Atom requirement)."""
        # Convert to UTC if not already
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=UTC)
        elif dt.tzinfo != UTC:
            dt = dt.astimezone(UTC)

        # Format as RFC 3339: 2024-12-04T15:30:45Z
        return dt.strftime("%Y-%m-%dT%H:%M:%SZ")


def documents_to_feed(
    docs: list[Document],
    feed_id: str,
    title: str,
    authors: list[Author] | None = None,
) -> Feed:
    """Aggregates documents into a valid Atom Feed."""
    if not docs:
        updated = datetime.now(UTC)
    else:
        updated = max(doc.updated for doc in docs)

    # Sort documents by updated timestamp descending (newest first)
    sorted_docs = sorted(docs, key=lambda d: d.updated, reverse=True)

    return Feed(id=feed_id, title=title, updated=updated, authors=authors or [], entries=sorted_docs)
