"""Core Data Types for Egregora V3."""

import hashlib
import uuid
from datetime import UTC, datetime
from enum import Enum
from typing import Any
from xml.etree.ElementTree import Element, register_namespace, SubElement, tostring

from markdown_it import MarkdownIt
from pydantic import BaseModel, Field, model_validator
from egregora_v3.core.utils import slugify


# A fixed namespace for Egregora documents. This ensures that the same name
# (hash input) within this namespace will always produce the same UUID.
EGREGORA_NAMESPACE = uuid.UUID("f6a8e3b2-b1e4-4a8f-8f0a-9e1e9e1e9e1e")


# --- XML Configuration ---

# Register namespaces globally to ensure pretty prefixes in all XML output
# This is a module-level side effect, but necessary for clean Atom feeds.
try:
    from xml.etree.ElementTree import register_namespace
    register_namespace("", "http://www.w3.org/2005/Atom")
    register_namespace("thr", "http://purl.org/syndication/thread/1.0")
except Exception:  # pragma: no cover
    # Best effort registration; may fail in some environments or if already registered
    pass

# --- Markdown Renderer ---
_md = MarkdownIt("commonmark", {"html": True})


# --- Atom Core Domain ---


class Link(BaseModel):
    href: str
    rel: str | None = None  # ex: "alternate", "enclosure", "self", "in-reply-to"
    type: str | None = None  # ex: "text/html", "image/jpeg"
    hreflang: str | None = None
    title: str | None = None
    length: int | None = None


class Author(BaseModel):
    name: str
    email: str | None = None
    uri: str | None = None


class Category(BaseModel):
    term: str  # A tag or category
    scheme: str | None = None  # URI of the taxonomy scheme
    label: str | None = None  # Readable label


class Source(BaseModel):
    id: str | None = None
    title: str | None = None
    updated: datetime | None = None
    links: list[Link] = Field(default_factory=list)


class InReplyTo(BaseModel):
    """Atom Threading Extension (RFC 4685)."""

    ref: str  # ID of the parent entry
    href: str | None = None  # Link to the parent entry
    type: str | None = None


class Entry(BaseModel):
    id: str  # URI or stable unique ID
    title: str
    updated: datetime
    published: datetime | None = None

    links: list[Link] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    contributors: list[Author] = Field(default_factory=list)
    categories: list[Category] = Field(default_factory=list)

    summary: str | None = None  # Short text / Teaser
    content: str | None = None  # Main body (Markdown/HTML)
    content_type: str | None = None  # ex: "text/markdown"

    source: Source | None = None

    # Threading (RFC 4685)
    in_reply_to: InReplyTo | None = None

    # Public extensions (Atom compliant)
    extensions: dict[str, Any] = Field(default_factory=dict)

    # Internal system metadata (not serialized to public Atom)
    internal_metadata: dict[str, Any] = Field(default_factory=dict)

    @property
    def html_content(self) -> str | None:
        """Render markdown content to HTML."""
        if self.content:
            return _md.render(self.content).strip()
        return None

    @property
    def is_document(self) -> bool:
        """Type guard for Jinja templates."""
        return False

    @property
    def has_enclosure(self) -> bool:
        """Check if entry has a media enclosure link."""
        if not self.links:
            return False

        return any(
            link.rel == "enclosure"
            and link.type
            and (
                link.type.startswith("image/")
                or link.type.startswith("audio/")
                or link.type.startswith("video/")
            )
            for link in self.links
        )


# --- Application Domain ---


class DocumentType(str, Enum):
    RECAP = "recap"
    NOTE = "note"
    PLAN = "plan"
    POST = "post"
    MEDIA = "media"
    PROFILE = "profile"
    ENRICHMENT = "enrichment"
    CONCEPT = "concept"


class DocumentStatus(str, Enum):
    DRAFT = "draft"
    PUBLISHED = "published"
    ARCHIVED = "archived"


class Document(Entry):
    """Represents an artifact generated by Egregora.

    Inherits from Entry to ensure Atom compatibility.
    """

    doc_type: DocumentType
    status: DocumentStatus = DocumentStatus.DRAFT

    # RAG Indexing Policy
    searchable: bool = True

    # Suggestion for path for file-based OutputAdapters (MkDocs/Hugo)
    url_path: str | None = None

    @property
    def is_document(self) -> bool:
        """Type guard for Jinja templates."""
        return True

    @property
    def slug(self) -> str | None:
        """Get the semantic slug for this document."""
        return self.internal_metadata.get("slug")

    @model_validator(mode='before')
    @classmethod
    def _validate_and_set_fields(cls, data: Any) -> Any:
        if isinstance(data, dict):
            # Ensure slug exists if title is present
            if data.get('title') and not data.get('internal_metadata', {}).get('slug'):
                if 'internal_metadata' not in data:
                    data['internal_metadata'] = {}
                data['internal_metadata']['slug'] = slugify(data['title'])

            # Set id if not present
            if not data.get('id'):
                title = data.get('title')
                content = data.get('content')

                if not title and not content:
                    # Pydantic will catch the missing required fields later,
                    # but we can't generate an ID without at least one.
                    pass
                else:
                    # If one is None, use an empty string to ensure the hash is consistent.
                    title_str = title or ""
                    content_str = content or ""

                    hash_input = f"{title_str}:{content_str}"
                    content_hash = hashlib.sha1(hash_input.encode('utf-8')).hexdigest()  # nosec B324
                    data['id'] = f"urn:uuid:{uuid.uuid5(EGREGORA_NAMESPACE, content_hash)}"

            # Set updated timestamp if not present
            if 'updated' not in data:
                data['updated'] = datetime.now(UTC)

        return data



class Feed(BaseModel):
    id: str
    title: str
    updated: datetime
    entries: list[Entry] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    links: list[Link] = Field(default_factory=list)

    def get_published_documents(self) -> list["Document"]:
        """Return only published documents from the feed entries."""
        return [
            doc
            for doc in self.entries
            if isinstance(doc, Document) and doc.status == DocumentStatus.PUBLISHED
        ]

    def to_xml(self) -> str:
        """Serialize the feed to an Atom XML string."""
        # Create the root element with namespaces
        root = Element("feed")
        root.set("xmlns", "http://www.w3.org/2005/Atom")
        root.set("xmlns:thr", "http://purl.org/syndication/thread/1.0")

        # --- Feed Metadata ---
        SubElement(root, "id").text = self.id
        SubElement(root, "title").text = self.title
        SubElement(root, "updated").text = self.updated.isoformat().replace("+00:00", "Z")

        for author in self.authors:
            author_elem = SubElement(root, "author")
            SubElement(author_elem, "name").text = author.name
            if author.email:
                SubElement(author_elem, "email").text = author.email

        for link in self.links:
            link_elem = SubElement(root, "link", attrib={"href": link.href})
            if link.rel:
                link_elem.set("rel", link.rel)
            if link.type:
                link_elem.set("type", link.type)

        # --- Entries ---
        for entry in self.entries:
            entry_elem = SubElement(root, "entry")
            SubElement(entry_elem, "id").text = entry.id
            SubElement(entry_elem, "title").text = entry.title
            SubElement(entry_elem, "updated").text = entry.updated.isoformat().replace("+00:00", "Z")

            if entry.published:
                SubElement(entry_elem, "published").text = entry.published.isoformat().replace("+00:00", "Z")

            for author in entry.authors:
                author_elem = SubElement(entry_elem, "author")
                SubElement(author_elem, "name").text = author.name

            if entry.content:
                content_type = entry.content_type or "text/plain"
                content_elem = SubElement(entry_elem, "content")
                content_elem.text = entry.content
                if content_type in ["text/html", "text/xhtml"]:
                    content_elem.set("type", "html")
                elif content_type == "text/markdown":
                    content_elem.set("type", "text")
                else:
                    content_elem.set("type", content_type)

            if entry.in_reply_to:
                reply_elem = SubElement(entry_elem, "thr:in-reply-to", attrib={"ref": entry.in_reply_to.ref})
                if entry.in_reply_to.href:
                    reply_elem.set("href", entry.in_reply_to.href)
                if entry.in_reply_to.type:
                    reply_elem.set("type", entry.in_reply_to.type)

            if isinstance(entry, Document):
                # Add doc_type and status as categories for filtering
                SubElement(
                    entry_elem,
                    "category",
                    attrib={
                        "scheme": "https://egregora.app/schema#doc_type",
                        "term": entry.doc_type.value,
                        "label": "Document Type",
                    },
                )
                SubElement(
                    entry_elem,
                    "category",
                    attrib={
                        "scheme": "https://egregora.app/schema#status",
                        "term": entry.status.value,
                        "label": "Document Status",
                    },
                )

        # Serialize to string
        return tostring(root, encoding="unicode", xml_declaration=True)

    @classmethod
    def from_documents(
        cls,
        docs: list["Document"],
        feed_id: str,
        title: str,
        authors: list[Author] | None = None,
    ) -> "Feed":
        """Aggregates documents into a valid Atom Feed."""
        if not docs:
            updated = datetime.now(UTC)
        else:
            updated = max(doc.updated for doc in docs)

        # Sort documents by updated timestamp descending (newest first)
        sorted_docs = sorted(docs, key=lambda d: d.updated, reverse=True)

        return cls(
            id=feed_id,
            title=title,
            updated=updated,
            authors=authors or [],
            entries=sorted_docs,
        )
