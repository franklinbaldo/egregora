"""Core Data Types for Egregora V3."""

import hashlib
import uuid
from datetime import UTC, datetime
from enum import Enum
from typing import Any

from pathlib import Path

from jinja2 import Environment, FileSystemLoader, select_autoescape
from markupsafe import Markup
from markdown_it import MarkdownIt
from pydantic import BaseModel, Field, model_validator

from egregora_v3.core.filters import format_datetime
from egregora_v3.core.utils import slugify

# --- Markdown Renderer ---
_md = MarkdownIt("commonmark", {"html": False})
_templates_dir = Path(__file__).resolve().parents[1] / "infra" / "sinks" / "templates"
_jinja_env = Environment(
    loader=FileSystemLoader(str(_templates_dir)),
    autoescape=True,
    trim_blocks=True,
    lstrip_blocks=True,
)
_jinja_env.filters["iso_utc"] = format_datetime


# --- Atom Core Domain ---


class Link(BaseModel):
    href: str
    rel: str | None = None  # ex: "alternate", "enclosure", "self", "in-reply-to"
    type: str | None = None  # ex: "text/html", "image/jpeg"
    hreflang: str | None = None
    title: str | None = None
    length: int | None = None


class Author(BaseModel):
    name: str
    email: str | None = None
    uri: str | None = None


class Category(BaseModel):
    term: str  # A tag or category
    scheme: str | None = None  # URI of the taxonomy scheme
    label: str | None = None  # Readable label


class Source(BaseModel):
    id: str | None = None
    title: str | None = None
    updated: datetime | None = None
    links: list[Link] = Field(default_factory=list)


class InReplyTo(BaseModel):
    """Atom Threading Extension (RFC 4685)."""

    ref: str  # ID of the parent entry
    href: str | None = None  # Link to the parent entry
    type: str | None = None


class Entry(BaseModel):
    id: str  # URI or stable unique ID
    title: str
    updated: datetime
    published: datetime | None = None

    links: list[Link] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    contributors: list[Author] = Field(default_factory=list)
    categories: list[Category] = Field(default_factory=list)

    summary: str | None = None  # Short text / Teaser
    content: str | None = None  # Main body (Markdown/HTML)
    content_type: str | None = None  # ex: "text/markdown"

    source: Source | None = None

    # Threading (RFC 4685)
    in_reply_to: InReplyTo | None = None

    # Public extensions (Atom compliant)
    extensions: dict[str, Any] = Field(default_factory=dict)

    # Internal system metadata (not serialized to public Atom)
    internal_metadata: dict[str, Any] = Field(default_factory=dict)

    @property
    def html_content(self) -> str | None:
        """Render markdown content to HTML."""
        if self.content:
            return _md.render(self.content).strip()
        return None

    @property
    def is_document(self) -> bool:
        """Type guard for Jinja templates."""
        return False

    @property
    def has_enclosure(self) -> bool:
        """Check if entry has a media enclosure link."""
        if not self.links:
            return False

        return any(
            link.rel == "enclosure"
            and link.type
            and (
                link.type.startswith("image/")
                or link.type.startswith("audio/")
                or link.type.startswith("video/")
            )
            for link in self.links
        )


# --- Application Domain ---


class DocumentType(str, Enum):
    RECAP = "recap"
    NOTE = "note"
    PLAN = "plan"
    POST = "post"
    MEDIA = "media"
    PROFILE = "profile"
    ENRICHMENT = "enrichment"
    CONCEPT = "concept"


class DocumentStatus(str, Enum):
    DRAFT = "draft"
    PUBLISHED = "published"
    ARCHIVED = "archived"


class Document(Entry):
    """Represents an artifact generated by Egregora.

    Inherits from Entry to ensure Atom compatibility.
    """

    doc_type: DocumentType
    status: DocumentStatus = DocumentStatus.DRAFT

    # RAG Indexing Policy
    searchable: bool = True

    # Suggestion for path for file-based OutputAdapters (MkDocs/Hugo)
    url_path: str | None = None

    @property
    def is_document(self) -> bool:
        """Type guard for Jinja templates."""
        return True

    @property
    def slug(self) -> str | None:
        """Get the semantic slug for this document."""
        return self.internal_metadata.get("slug")

    @classmethod
    def create(cls, **data: Any) -> "Document":
        """Convenience constructor mirroring pydantic's model creation."""
        return cls(**data)

    @model_validator(mode="before")
    @classmethod
    def _set_identity_and_timestamps(cls, data: Any) -> Any:
        """Set identity (id, slug) and timestamps before validation.

        This allows for declarative instantiation of Document and its subclasses
        without needing a factory method.
        """
        if not isinstance(data, dict):
            return data  # Not a dict, let Pydantic handle it

        # If 'id' is already set, respect it.
        if "id" in data and data["id"]:
            return data

        internal_metadata = data.get("internal_metadata", {})
        slug = internal_metadata.get("slug")

        # If still no slug, generate from title if it exists
        if not slug and data.get("title"):
            slug = slugify(str(data["title"]).strip())

        if slug:
            # Set the derived values
            data["id"] = slug
            if "internal_metadata" not in data:
                data["internal_metadata"] = {}
            data["internal_metadata"]["slug"] = slug

        # Set timestamp if not present
        if "updated" not in data:
            data["updated"] = datetime.now(UTC)

        return data


class Feed(BaseModel):
    id: str
    title: str
    updated: datetime
    entries: list[Entry] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    links: list[Link] = Field(default_factory=list)

    def get_published_documents(self) -> list["Document"]:
        """Return only published documents from the feed entries."""
        return [
            doc
            for doc in self.entries
            if isinstance(doc, Document) and doc.status == DocumentStatus.PUBLISHED
        ]

    def to_xml(self) -> str:
        """Serialize the feed to an Atom XML string using the shared Jinja template."""
        renderable_entries: list[Entry] = []
        for entry in self.entries:
            entry_copy = entry.model_copy(deep=True) if hasattr(entry, "model_copy") else entry
            # Normalize content rendering and types for template output
            if getattr(entry_copy, "content", None):
                if isinstance(entry_copy, Document):
                    if entry_copy.content_type == "text/markdown":
                        entry_copy.content_type = "text"
                    elif entry_copy.content_type in {None, "text/html", "text/xhtml", "html"}:
                        entry_copy.content = Markup(entry_copy.html_content or entry_copy.content)
                        entry_copy.content_type = "html"
                else:
                    if entry_copy.content_type == "text/markdown":
                        entry_copy.content_type = "text"
                    elif entry_copy.content_type is None:
                        entry_copy.content_type = "html"
            renderable_entries.append(entry_copy)

        feed_payload = self.model_copy(update={"entries": renderable_entries})

        template = _jinja_env.get_template("atom.xml.jinja")
        return template.render(feed=feed_payload).strip()

    @classmethod
    def from_documents(
        cls,
        docs: list["Document"],
        feed_id: str,
        title: str,
        authors: list[Author] | None = None,
    ) -> "Feed":
        """Aggregates documents into a valid Atom Feed."""
        if not docs:
            updated = datetime.now(UTC)
        else:
            updated = max(doc.updated for doc in docs)

        # Sort documents by updated timestamp descending (newest first)
        sorted_docs = sorted(docs, key=lambda d: d.updated, reverse=True)

        return cls(
            id=feed_id,
            title=title,
            updated=updated,
            authors=authors or [],
            entries=sorted_docs,
        )
