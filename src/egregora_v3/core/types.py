import hashlib
import uuid
from datetime import UTC, datetime
from enum import Enum
from typing import Any
from xml.etree.ElementTree import Element, register_namespace, SubElement, tostring

import jinja2
from pydantic import BaseModel, Field

from egregora_v3.core.filters import format_datetime, normalize_content_type
from egregora_v3.core.utils import slugify

# --- XML Configuration ---

# Register namespaces globally to ensure pretty prefixes in all XML output
# This is a module-level side effect, but necessary for clean Atom feeds.
try:
    register_namespace("", "http://www.w3.org/2005/Atom")
    register_namespace("thr", "http://purl.org/syndication/thread/1.0")
except Exception:  # pragma: no cover
    # Best effort registration; may fail in some environments or if already registered
    pass

# --- Jinja2 Environment ---

# Module-level Jinja2 environment for performance
# Data over logic: Template is data, not code.
_jinja_env = jinja2.Environment(
    loader=jinja2.PackageLoader("egregora_v3.core", "."),
    autoescape=True,
    trim_blocks=True,
    lstrip_blocks=True,
)

_jinja_env.filters["rfc3339"] = format_datetime
_jinja_env.filters["content_type"] = normalize_content_type
_jinja_env.globals["Document"] = "Document"  # Use string to avoid circular import issues if Document is used


# --- Atom Core Domain ---


class Link(BaseModel):
    href: str
    rel: str | None = None  # ex: "alternate", "enclosure", "self", "in-reply-to"
    type: str | None = None  # ex: "text/html", "image/jpeg"
    hreflang: str | None = None
    title: str | None = None
    length: int | None = None


class Author(BaseModel):
    name: str
    email: str | None = None
    uri: str | None = None


class Category(BaseModel):
    term: str  # A tag or category
    scheme: str | None = None  # URI of the taxonomy scheme
    label: str | None = None  # Readable label


class Source(BaseModel):
    id: str | None = None
    title: str | None = None
    updated: datetime | None = None
    links: list[Link] = Field(default_factory=list)


class InReplyTo(BaseModel):
    """Atom Threading Extension (RFC 4685)."""

    ref: str  # ID of the parent entry
    href: str | None = None  # Link to the parent entry
    type: str | None = None


class Entry(BaseModel):
    id: str  # URI or stable unique ID
    title: str
    updated: datetime
    published: datetime | None = None

    links: list[Link] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    contributors: list[Author] = Field(default_factory=list)
    categories: list[Category] = Field(default_factory=list)

    summary: str | None = None  # Short text / Teaser
    content: str | None = None  # Main body (Markdown/HTML)
    content_type: str | None = None  # ex: "text/markdown"

    source: Source | None = None

    # Threading (RFC 4685)
    in_reply_to: InReplyTo | None = None

    # Public extensions (Atom compliant)
    extensions: dict[str, Any] = Field(default_factory=dict)

    # Internal system metadata (not serialized to public Atom)
    internal_metadata: dict[str, Any] = Field(default_factory=dict)

    @property
    def is_document(self) -> bool:
        """Type guard for Jinja templates."""
        return False


# --- Application Domain ---


class DocumentType(str, Enum):
    RECAP = "recap"
    NOTE = "note"
    PLAN = "plan"
    POST = "post"
    MEDIA = "media"
    PROFILE = "profile"
    ENRICHMENT = "enrichment"
    CONCEPT = "concept"


class DocumentStatus(str, Enum):
    DRAFT = "draft"
    PUBLISHED = "published"
    ARCHIVED = "archived"


class Document(Entry):
    """Represents an artifact generated by Egregora.

    Inherits from Entry to ensure Atom compatibility.
    """

    doc_type: DocumentType
    status: DocumentStatus = DocumentStatus.DRAFT

    # RAG Indexing Policy
    searchable: bool = True

    # Suggestion for path for file-based OutputAdapters (MkDocs/Hugo)
    url_path: str | None = None

    @property
    def is_document(self) -> bool:
        """Type guard for Jinja templates."""
        return True

    @property
    def slug(self) -> str | None:
        """Get the semantic slug for this document."""
        return self.internal_metadata.get("slug")

    @classmethod
    def create(  # noqa: PLR0913
        cls,
        content: str,
        doc_type: DocumentType,
        title: str,
        *,
        status: DocumentStatus = DocumentStatus.DRAFT,
        internal_metadata: dict[str, Any] | None = None,
        slug: str | None = None,
        searchable: bool = True,
        in_reply_to: InReplyTo | None = None,
    ) -> "Document":
        """Factory method to create a Document.

        Identity is always derived from the slug.
        One good path over many flexible paths.
        """
        if internal_metadata is None:
            internal_metadata = {}

        # Generate slug from title if not provided.
        if slug is not None:
            final_slug = slug
        else:
            final_slug = slugify(title.strip())

        if not final_slug:
            msg = "Document must have a slug or a title to generate one."
            raise ValueError(msg)

        internal_metadata["slug"] = final_slug

        return cls(
            id=final_slug,
            title=title,
            updated=datetime.now(UTC),
            content=content,
            doc_type=doc_type,
            status=status,
            internal_metadata=internal_metadata,
            searchable=searchable,
            in_reply_to=in_reply_to,
        )


class Feed(BaseModel):
    id: str
    title: str
    updated: datetime
    entries: list[Entry] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    links: list[Link] = Field(default_factory=list)

    def to_xml(self) -> str:
        """Generate Atom XML feed (RFC 4287 compliant) using a Jinja2 template."""
        template = _jinja_env.get_template("atom.xml.jinja")
        return template.render(feed=self)


def documents_to_feed(
    docs: list[Document],
    feed_id: str,
    title: str,
    authors: list[Author] | None = None,
) -> Feed:
    """Aggregates documents into a valid Atom Feed."""
    if not docs:
        updated = datetime.now(UTC)
    else:
        updated = max(doc.updated for doc in docs)

    # Sort documents by updated timestamp descending (newest first)
    sorted_docs = sorted(docs, key=lambda d: d.updated, reverse=True)

    return Feed(id=feed_id, title=title, updated=updated, authors=authors or [], entries=sorted_docs)
