import hashlib
import uuid
from datetime import UTC, datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field

from egregora.utils.paths import slugify


# --- Atom Core Domain ---

class Link(BaseModel):
    href: str
    rel: str | None = None        # ex: "alternate", "enclosure", "self", "in-reply-to"
    type: str | None = None       # ex: "text/html", "image/jpeg"
    hreflang: str | None = None
    title: str | None = None
    length: int | None = None

class Author(BaseModel):
    name: str
    email: str | None = None
    uri: str | None = None

class Category(BaseModel):
    term: str                     # A tag or category
    scheme: str | None = None     # URI of the taxonomy scheme
    label: str | None = None      # Readable label

class Source(BaseModel):
    id: str | None = None
    title: str | None = None
    updated: datetime | None = None
    links: list[Link] = Field(default_factory=list)

class InReplyTo(BaseModel):
    """Atom Threading Extension (RFC 4685)"""
    ref: str                      # ID of the parent entry
    href: str | None = None       # Link to the parent entry
    type: str | None = None

class Entry(BaseModel):
    id: str                       # URI or stable unique ID
    title: str
    updated: datetime
    published: datetime | None = None

    links: list[Link] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    contributors: list[Author] = Field(default_factory=list)
    categories: list[Category] = Field(default_factory=list)

    summary: str | None = None    # Short text / Teaser
    content: str | None = None    # Main body (Markdown/HTML)
    content_type: str | None = None # ex: "text/markdown"

    source: Source | None = None

    # Threading (RFC 4685)
    in_reply_to: InReplyTo | None = None

    # Public extensions (Atom compliant)
    extensions: dict[str, Any] = Field(default_factory=dict)

    # Internal system metadata (not serialized to public Atom)
    internal_metadata: dict[str, Any] = Field(default_factory=dict)

    # Public extensions (Atom compliant)
    extensions: dict[str, Any] = Field(default_factory=dict)

# --- Application Domain ---

class DocumentType(str, Enum):
    RECAP = "recap"
    NOTE = "note"
    PLAN = "plan"
    POST = "post"
    MEDIA = "media"
    PROFILE = "profile"
    ENRICHMENT = "enrichment"

class DocumentStatus(str, Enum):
    DRAFT = "draft"
    PUBLISHED = "published"
    ARCHIVED = "archived"

class Document(Entry):
    """
    Represents an artifact generated by Egregora.
    Inherits from Entry to ensure Atom compatibility.
    """
    doc_type: DocumentType
    status: DocumentStatus = DocumentStatus.DRAFT

    # RAG Indexing Policy
    searchable: bool = True

    # Suggestion for path for file-based OutputAdapters (MkDocs/Hugo)
    url_path: str | None = None

    @classmethod
    def create(cls,
               content: str,
               doc_type: DocumentType,
               title: str,
               status: DocumentStatus = DocumentStatus.DRAFT,
               internal_metadata: dict[str, Any] | None = None,
               id_override: str | None = None,
               slug: str | None = None) -> "Document":
        """Factory method to create a Document.

        V3 CHANGE: Supports Semantic Identity.
        If `slug` is provided (and type is POST/MEDIA), it acts as the ID.
        If `id_override` is provided, it acts as the ID.
        Otherwise, generates a content-addressed ID (UUIDv5).
        """
        if internal_metadata is None:
            internal_metadata = {}

        # Update metadata with slug if provided
        if slug:
            internal_metadata["slug"] = slug

        # Determine ID
        doc_id = None
        if id_override:
            doc_id = id_override
        elif slug and doc_type in (DocumentType.POST, DocumentType.MEDIA):
            # Semantic Identity
            clean_slug = slugify(slug, max_len=60)
            if clean_slug:
                doc_id = clean_slug

        # Fallback to UUIDv5
        if not doc_id:
            hasher = hashlib.sha256()
            hasher.update(content.encode('utf-8'))
            hasher.update(doc_type.value.encode('utf-8'))
            doc_id = str(uuid.uuid5(uuid.NAMESPACE_DNS, hasher.hexdigest()))

        return cls(
            id=doc_id,
            title=title,
            updated=datetime.now(UTC),
            content=content,
            doc_type=doc_type,
            status=status,
            internal_metadata=internal_metadata,
            in_reply_to=in_reply_to,
            searchable=searchable
        )


class Feed(BaseModel):
    id: str
    title: str
    updated: datetime
    entries: list[Entry] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    links: list[Link] = Field(default_factory=list)


def documents_to_feed(
    docs: list[Document],
    feed_id: str,
    title: str,
    authors: list[Author] | None = None,
) -> Feed:
    """Aggregates documents into a valid Atom Feed."""
    if not docs:
        updated = datetime.now(UTC)
    else:
        updated = max(doc.updated for doc in docs)

    return Feed(
        id=feed_id,
        title=title,
        updated=updated,
        authors=authors or [],
        entries=docs
    )
