"""Core Data Types for Egregora V3."""

import hashlib
import uuid
from datetime import UTC, datetime
from enum import Enum
from typing import Any, ForwardRef
from xml.etree.ElementTree import Element, register_namespace, SubElement, tostring

from markdown_it import MarkdownIt
from pydantic import BaseModel, Field, model_validator

from egregora.utils.text import InvalidInputError
from egregora.core.utils import slugify

# --- XML Configuration ---

NAMESPACE_DOCUMENT = uuid.UUID("6ba7b810-9dad-11d1-80b4-00c04fd430c8")

# Register namespaces globally to ensure pretty prefixes in all XML output
# This is a module-level side effect, but necessary for clean Atom feeds.
try:
    from xml.etree.ElementTree import register_namespace
    register_namespace("", "http://www.w3.org/2005/Atom")
    register_namespace("thr", "http://purl.org/syndication/thread/1.0")
except Exception:  # pragma: no cover
    # Best effort registration; may fail in some environments or if already registered
    pass

# --- Markdown Renderer ---
_md = MarkdownIt("commonmark", {"html": True})


# --- Atom Core Domain ---


class Link(BaseModel):
    href: str
    rel: str | None = None  # ex: "alternate", "enclosure", "self", "in-reply-to"
    type: str | None = None  # ex: "text/html", "image/jpeg"
    hreflang: str | None = None
    title: str | None = None
    length: int | None = None


class Author(BaseModel):
    name: str
    email: str | None = None
    uri: str | None = None


class Category(BaseModel):
    term: str  # A tag or category
    scheme: str | None = None  # URI of the taxonomy scheme
    label: str | None = None  # Readable label


class Source(BaseModel):
    id: str | None = None
    title: str | None = None
    updated: datetime | None = None
    links: list[Link] = Field(default_factory=list)


class InReplyTo(BaseModel):
    """Atom Threading Extension (RFC 4685)."""

    ref: str  # ID of the parent entry
    href: str | None = None  # Link to the parent entry
    type: str | None = None


class Entry(BaseModel):
    id: str  # URI or stable unique ID
    title: str
    updated: datetime
    published: datetime | None = None

    links: list[Link] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    contributors: list[Author] = Field(default_factory=list)
    categories: list[Category] = Field(default_factory=list)

    summary: str | None = None  # Short text / Teaser
    content: str | None = None  # Main body (Markdown/HTML)
    content_type: str | None = None  # ex: "text/markdown"

    source: Source | None = None

    # Threading (RFC 4685)
    in_reply_to: InReplyTo | None = None

    # Public extensions (Atom compliant)
    extensions: dict[str, Any] = Field(default_factory=dict)

    # Internal system metadata (not serialized to public Atom)
    internal_metadata: dict[str, Any] = Field(default_factory=dict)

    @property
    def html_content(self) -> str | None:
        """Render markdown content to HTML."""
        if self.content:
            return _md.render(self.content).strip()
        return None

    @property
    def is_document(self) -> bool:
        """Type guard for Jinja templates."""
        return False

    @property
    def has_enclosure(self) -> bool:
        """Check if entry has a media enclosure link."""
        if not self.links:
            return False

        return any(
            link.rel == "enclosure"
            and link.type
            and (
                link.type.startswith("image/")
                or link.type.startswith("audio/")
                or link.type.startswith("video/")
            )
            for link in self.links
        )


# --- Application Domain ---


class DocumentType(str, Enum):
    RECAP = "recap"
    NOTE = "note"  # TODO: Deprecate in favor of JOURNAL?
    JOURNAL = "journal"
    PLAN = "plan"
    POST = "post"
    MEDIA = "media"
    PROFILE = "profile"
    ENRICHMENT = "enrichment"
    CONCEPT = "concept"
    # Added from data_primitives for compatibility
    ANNOUNCEMENT = "announcement"
    ENRICHMENT_URL = "enrichment_url"
    ENRICHMENT_MEDIA = "enrichment_media"
    ENRICHMENT_IMAGE = "enrichment_image"
    ENRICHMENT_VIDEO = "enrichment_video"
    ENRICHMENT_AUDIO = "enrichment_audio"
    ANNOTATION = "annotation"


class DocumentStatus(str, Enum):
    DRAFT = "draft"
    PUBLISHED = "published"
    ARCHIVED = "archived"


class Document(Entry):
    """Represents an artifact generated by Egregora.

    Inherits from Entry to ensure Atom compatibility.
    """

    doc_type: DocumentType = Field(alias="type")
    status: DocumentStatus = DocumentStatus.DRAFT

    # RAG Indexing Policy
    searchable: bool = True

    # Suggestion for path for file-based OutputAdapters (MkDocs/Hugo)
    url_path: str | None = None

    # Compatibility fields
    parent_id: str | None = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
    source_window: str | None = None
    suggested_path: str | None = None

    @property
    def is_document(self) -> bool:
        """Type guard for Jinja templates."""
        return True

    @property
    def type(self) -> DocumentType:
        """Alias for doc_type to maintain compatibility."""
        return self.doc_type

    @property
    def metadata(self) -> dict[str, Any]:
        """Alias for internal_metadata to maintain compatibility."""
        return self.internal_metadata

    @property
    def document_id(self) -> str:
        """Alias for id to maintain compatibility."""
        return self.id

    def with_parent(self, parent: "Document | str") -> "Document":
        """Return new document with parent relationship."""
        parent_id = parent.document_id if hasattr(parent, "document_id") else parent
        return self.model_copy(update={"parent_id": parent_id})

    def with_metadata(self, **updates: Any) -> "Document":
        """Return new document with updated metadata."""
        new_meta = self.internal_metadata.copy()
        new_meta.update(updates)
        return self.model_copy(update={"internal_metadata": new_meta})

    @property
    def slug(self) -> str | None:
        """Get the semantic slug for this document."""
        return self.internal_metadata.get("slug")

    @classmethod
    def _ensure_slug(cls, data: dict[str, Any]) -> None:
        """Ensure the document has a slug and ID."""
        if "id" in data and data["id"]:
            return

        internal_metadata = data.get("internal_metadata", {})
        # Also check "metadata" alias if present in input dict (e.g. from legacy code)
        if not internal_metadata and "metadata" in data:
            internal_metadata = data["metadata"]
            if "internal_metadata" not in data:
                data["internal_metadata"] = internal_metadata

        slug = internal_metadata.get("slug")

        # If still no slug, generate from title if it exists
        title = data.get("title")
        if not slug and title and isinstance(title, str) and title.strip():
            try:
                slug = slugify(title)
            except InvalidInputError:
                pass

        if slug:
            # If ID is missing, set it to slug
            if "id" not in data:
                data["id"] = slug
            internal_metadata["slug"] = slug

    @classmethod
    def _ensure_updated_timestamp(cls, data: dict[str, Any]) -> None:
        """Ensure the document has an updated timestamp."""
        if "updated" not in data:
            data["updated"] = datetime.now(UTC)

    @classmethod
    def _ensure_id_fallback(cls, data: dict[str, Any]) -> None:
        """Ensure ID exists, falling back to content hash."""
        if data.get("id"):
            return

        content = data.get("content")
        if content:
            if isinstance(content, bytes):
                payload = content
            else:
                payload = str(content).encode("utf-8")
            content_hash = hashlib.sha256(payload).hexdigest()
            data["id"] = str(uuid.uuid5(NAMESPACE_DOCUMENT, content_hash))

    @model_validator(mode="before")
    @classmethod
    def _set_identity_and_timestamps(cls, data: Any) -> Any:
        """Set identity (id, slug) and timestamps before validation."""
        if not isinstance(data, dict):
            return data

        # Map 'metadata' to 'internal_metadata' if present
        if "metadata" in data and "internal_metadata" not in data:
            data["internal_metadata"] = data["metadata"]

        # Map 'type' to 'doc_type' is handled by alias="type" in Field,
        # but if we access data dict directly we might need to be careful.

        # Ensure title if missing (Entry requires title)
        if "title" not in data:
            data["title"] = "Untitled"

        cls._ensure_slug(data)

        # Fallback to content-based ID if slug/explicit ID not present
        if not data.get("id"):
            cls._ensure_id_fallback(data)

        cls._ensure_updated_timestamp(data)
        return data


class Feed(BaseModel):
    id: str
    title: str
    updated: datetime
    entries: list[Entry] = Field(default_factory=list)
    authors: list[Author] = Field(default_factory=list)
    links: list[Link] = Field(default_factory=list)

    def to_xml(self) -> str:
        """Serialize this feed to an Atom XML string."""
        from egregora.core.atom import feed_to_xml_string

        return feed_to_xml_string(self)

    def get_published_documents(self) -> list["Document"]:
        """Return only published documents from the feed entries."""
        return [
            doc
            for doc in self.entries
            if isinstance(doc, Document) and doc.status == DocumentStatus.PUBLISHED
        ]

    @classmethod
    def from_documents(
        cls,
        docs: list["Document"],
        feed_id: str,
        title: str,
        authors: list[Author] | None = None,
    ) -> "Feed":
        """Aggregates documents into a valid Atom Feed."""
        if not docs:
            updated = datetime.now(UTC)
        else:
            updated = max(doc.updated for doc in docs)

        # Sort documents by updated timestamp descending (newest first)
        sorted_docs = sorted(docs, key=lambda d: d.updated, reverse=True)

        return cls(
            id=feed_id,
            title=title,
            updated=updated,
            authors=authors or [],
            entries=sorted_docs,
        )
