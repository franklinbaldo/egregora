Egregora (current version) — Stabilization & Cleanup Plan

This document is meant to be dropped into the repo as something like PLAN_CURRENT_VERSION_FIXES.md.

It does two things:

1. calls out specific problems in the current codebase and why they’re harmful, and


2. lays out an ordered plan (PR-sized chunks) to fix them without “jumping to v3”.




---

Goals (for current Egregora)

Make the repo reliable to work on: tooling must fail loudly and explain why.

Make the generated site consistently navigable: no broken links, one clear content layout.

Make docs match reality: especially security/privacy claims.

Make tests a safety net, not a suggestion: remove “expected failures” as a normal mode.

Reduce maintenance cost: dead code removal + module sprawl cleanup.


Non-goal: redesigning architecture around v3.


---

What’s bad right now (and why it matters)

1) Pre-commit hooks fail silently (developer-hostile)

Two dev tools return non-zero when they find issues… but they don’t print the issues. They literally loop through the errors and pass.

dev_tools/check_private_imports.py: errors are collected, but on failure it does for _error in all_errors: pass and returns 1.

dev_tools/check_test_config.py: same pattern—collects all_errors, then pass, then return 1.

These hooks are wired into .pre-commit-config.yaml, so devs hit a failure that gives zero actionable information.


Why this is bad: it trains contributors to disable hooks, ignore failures, or resent the toolchain. It also makes CI failures expensive to debug.


---

2) Docs & policy text drift away from the actual repo state (trust problem)

Examples:

SECURITY.md mentions a security@egregora.example (TBD) contact, which is placeholder text.

SECURITY.md claims a specific dev workflow (“run python dev_tools/setup_hooks.py”) and “Privacy-by-design” assertions.

Meanwhile, the repo explicitly documents that the privacy module directory was deleted (and other features disabled/removed).

There’s also a “privacy disabled” state described (pii_prevention set to None, no privacy filtering), reinforcing that privacy is not currently enforced.


Why this is bad: when security/privacy text doesn’t reflect actual behavior, you lose credibility and create real risk (users may rely on guarantees that aren’t true).


---

3) “Expected failures” in tests normalize a broken test suite

A testing doc explicitly says some tests are expected to fail (e.g., runs command, parquet adapter).

Why this is bad: once “some tests failing is normal”, nobody trusts CI. It also breaks contributor flow (people don’t know if their change caused the red build).


---

4) Generated site UX issues: folder confusion, broken links, naming inconsistencies, missing indexes

Your own UX evaluation report calls out production-blockers:

Folder structure confusion (content spread across multiple folders; mismatch with “unified structure” intent).

Broken media links and MkDocs nav warnings about missing media/index.md and broken cross-links.

Missing index pages and lack of rich post listings/filtering.


Why this is bad: users can’t reliably navigate the site, and the build emits warnings that are easy to ignore until they become 404s in production.


---

5) Template/init code has “sloppy” signals that correlate with downstream breakage

Example: the init scaffolder adds media/index.md twice in templates_to_render.

Also, .gitignore ignores root-level /media/, /posts/, /profiles/, /index.md, etc.
That’s fine if intentional, but it’s a strong hint you have two competing concepts of “site output vs site source” that leak into each other and confuse users.

Why this is bad: it creates paper cuts, drift, and inconsistent repos generated by different runs.


---

6) Module sprawl and scattered responsibilities increase change-risk

The repo TODO itself describes:

privacy utilities scattered (anonymization / PII redaction spread across adapters/agents)

MkDocs publishing logic leaking outside the MkDocs adapter

writer agent split across multiple files (“writer module sprawl”)


Why this is bad: every feature touches many places, which slows you down and makes regressions likely.


---

7) Dead code risk is acknowledged, but not enforced

You already have a dead-code detection guide and recommended CI integration via vulture.

Why this is bad: after large deletions, dead code becomes a drag and a source of subtle bugs. Without an enforced routine, it accumulates again.


---

The plan (PR-sized, ordered, with “definition of done”)

Guiding principles for the fixes

Fail loudly: any check that blocks commit/CI must print actionable errors.

One source of truth: docs must describe current behavior, not past intentions.

One content model: pick a single on-disk layout for generated docs and stick to it.

Green main: no “expected failing tests” on default CI.

Small PRs: each PR should be independently reviewable and revertable.



---

Workstream A — Tooling that tells you what’s wrong

A1) Fix check_private_imports to print errors

Current behavior: returns 1 but prints nothing.

Change:

Print each error to stderr

Return 1

Add a small unit test to assert output is present when violations exist (use capsys)


Definition of done:

Running the hook locally shows a list of file:line messages.

CI/pre-commit failure includes the same output.


A2) Fix check_test_config to print errors

Same silent failure issue.

Change:

Print errors to stderr

Add test coverage

Consider also printing a short hint (“use fixture X”) since the tool already has human messages in VIOLATIONS.


A3) Make pre-commit config consistent and documented

.pre-commit-config.yaml currently wires these hooks in.

Change:

Add docs/dev/pre-commit.md (short) with:

how to install

how to run hooks

what to do when they fail



Definition of done:

New contributor can run pre-commit run -a and understand failures.



---

Workstream B — Tests must be trustworthy again

B1) Remove “expected failures” as a normal workflow

The test doc explicitly expects failures for removed/disabled features.

Recommendation (pick one path, but do it repo-wide):

1. Hard-remove tests for removed features (best if the feature is truly gone), or


2. mark them xfail(strict=True, reason="feature removed on YYYY-MM-DD") temporarily, then delete in next cleanup cycle.



Definition of done:

Default CI run is green.

There is no instruction telling people to accept red tests.


B2) Split “smoke” vs “integration” clearly

Right now the docs suggest a mix of CLI, imports, VCR-based tests, etc.

Change:

Add make test (or scripts/test.sh) with:

unit (fast, no network)

e2e (optional, requires keys / VCR)


CI runs unit by default; integration is either scheduled or gated by secret availability.


Definition of done:

Contributors know which test tier to run before pushing.



---

Workstream C — Security & privacy: align claims with reality

C1) Fix SECURITY.md so it’s not aspirational text

Issues:

Placeholder email security@egregora.example (TBD)

Claims like “Privacy-by-design” need to match actual default behavior.

Repo documents privacy module deletion.


Change:

Replace placeholder contact with:

GitHub Security Advisories as primary (already listed)

remove fake email unless you actually own/monitor one


Update “Privacy-by-design” section to one of:

Option A (truthful minimalism): “privacy features are currently limited/optional; users must enable redaction; do not assume PII removal by default.”

Option B (restore minimal guarantee): ship a minimal privacy module and turn it on by default for specific adapters.



My recommendation: Option A now, and only move to Option B if you want to market “privacy-by-design” as a real feature. The repo currently documents “no privacy filtering applied” in places.

Definition of done:

SECURITY.md contains only statements you can defend from the codebase.


C2) Reconcile TODO items about privacy with the current repo direction

TODO proposes centralizing privacy utilities.

Change:

Either:

remove privacy-related TODO if privacy is out of scope for current version, or

add a scoped task: “minimal redaction library + tests + documented default-off/on semantics”




---

Workstream D — Generated site structure and links (make UX “production-safe”)

D1) Choose one content layout and enforce it

The UX report shows confusing split folders and suggests unification.

Recommendation: Make docs/posts/ the “content hub” and treat profiles/journal as typed documents inside posts (frontmatter type:) — consistent with the report noting templates already moved that direction.

Change:

One canonical location for content pages.

Other sections (Profiles, Journal) become views (indexes) not separate content trees.


Definition of done:

MkDocs nav points to pages that exist.

No duplicated content directories.


D2) Fix broken media nav and cross-references

The report shows MkDocs warnings for missing media/index.md and broken ../journal/index.md link.

Change:

Ensure the scaffolder always creates the referenced files

Add a CI step: mkdocs build -s (strict) after fixes so warnings fail the build


Definition of done:

mkdocs build has zero missing-file/nav warnings.


D3) Fix init/scaffolder duplication and layout leaks

The scaffolder renders media/index.md twice.

Change:

Remove duplicate entry

Add a test: “template list contains unique targets”

Clarify “generated output vs source docs” (see .gitignore root ignores).


Definition of done:

egregora init produces a clean, consistent tree every time.



---

Workstream E — Naming + URL stability (stop leaking UUIDs into UX)

The UX report explicitly calls out mixed naming (UUIDs vs slugs) and that it hurts content organization.

E1) Establish a naming policy

Policy proposal:

URLs/slugs are human-readable

UUIDs exist only as internal identifiers in frontmatter metadata


Examples:

posts: YYYY-MM-DD-title-slug.md

profiles: profiles/<handle-or-name-slug>.md (or typed doc pages in posts)

media assets: media/<type>/<hash-or-slug>.<ext>


E2) Implement a “slug resolver”

Derive slugs from canonical fields (title/name)

Persist mapping uuid -> slug in generated frontmatter to keep stability across rebuilds


Definition of done:

No UUID-only pages visible in navigation.

Links remain stable across regenerations.



---

Workstream F — Index pages and discoverability (make it feel like a real blog)

The UX report flags missing rich index pages and no filtering by date/tag/author.

F1) Generate rich indexes automatically

At minimum:

posts/index.md: recent posts list

posts/tags.md: tag cloud + per-tag pages (or anchors)

profiles/index.md: profile cards list (if profiles remain separate)


Definition of done:

A new user can browse “recent posts” and “tags” without knowing paths.


F2) Add link-checking and nav-checking in CI

Once the structure is stable:

mkdocs build --strict

optional: run a link checker against the built site



---

Workstream G — Dead code cleanup as a recurring practice

You already recommend vulture usage and even show how to add it to CI.

G1) Do one “dead code sweep” after the above refactors land

run vulture with a conservative threshold

remove dead exports, orphan helpers, stale config references

update docs mentioning removed features


G2) Make it hard for dead code to creep back

add a CI job that runs vulture periodically (weekly or on demand), not necessarily on every PR if noisy at first


Definition of done:

A vulture report exists and is small enough to reason about.



---

Execution plan (recommended PR sequence)

PR 1 — Make pre-commit hooks actionable

print errors in both check_private_imports and check_test_config

add tests asserting output


PR 2 — Make tests green by default

delete or xfail(strict=True) the “expected failures” tests

document test tiers


PR 3 — Fix SECURITY.md and related docs drift

remove placeholder email

rewrite privacy section to match actual behavior


PR 4 — Fix init/scaffolding correctness

remove duplicate media index entry

align scaffold tree vs .gitignore expectations


PR 5 — Fix MkDocs output: no broken links, one layout

resolve media/journal link warnings

unify folder structure

add mkdocs build --strict to CI once clean


PR 6 — Naming/slug policy + migration

stop leaking UUIDs into navigable pages

add uuid->slug mapping in metadata


PR 7 — Rich indexes (posts/tags/profiles)

address missing index pages


PR 8 — Dead code sweep + vulture routine

follow your existing guide



---

“Definition of done” checklist (repo-wide)

[ ] Pre-commit failures always show actionable error output.

[ ] Default CI is green (no “expected failures”).

[ ] mkdocs build produces zero missing nav/link warnings.

[ ] One canonical content layout exists (and is documented).

[ ] Human-readable slugs for user-facing pages; UUIDs only as internal metadata.

[ ] Index pages exist and are useful (recent posts, tags, profiles).

[ ] SECURITY.md contains no placeholders and no claims you can’t back up.

[ ] Dead code is periodically checked (at least manually, ideally automated).



---

Quick wins you can do immediately (high ROI)

1. Fix silent hooks (PR 1). This is pure developer happiness and reduces friction instantly.


2. Remove “expected failures” from normal CI (PR 2).


3. Make MkDocs nav warnings fail the build after you fix them (PR 5).




---

If you want, I can turn this plan into a set of ready-to-open GitHub issues (titles + checklists + file paths) that match this PR order.
