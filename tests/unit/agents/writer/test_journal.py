"""Unit tests for writer journal module."""

from datetime import UTC, datetime
from unittest.mock import MagicMock, patch

from pydantic_ai.messages import (
    ModelRequest,
    ModelResponse,
    TextPart,
    ThinkingPart,
    ToolCallPart,
    ToolReturnPart,
)

from egregora.agents.writer.journal import (
    JOURNAL_TYPE_TEXT,
    JOURNAL_TYPE_THINKING,
    JOURNAL_TYPE_TOOL_CALL,
    JOURNAL_TYPE_TOOL_RETURN,
    JournalEntry,
    JournalEntryParams,
    _create_tool_call_entry,
    _process_response_part,
    extract_intercalated_log,
    extract_journal_content,
    save_journal_to_file,
)
from egregora.data_primitives.document import DocumentType


class TestJournalLogic:
    def test_create_tool_call_entry(self):
        timestamp = datetime(2024, 1, 1, 12, 0, 0, tzinfo=UTC)
        part = ToolCallPart(tool_name="test_tool", args={"arg1": "value1"}, tool_call_id="call_1")
        entry = _create_tool_call_entry(part, timestamp)

        assert entry.entry_type == JOURNAL_TYPE_TOOL_CALL
        assert entry.tool_name == "test_tool"
        assert entry.timestamp == timestamp
        assert "test_tool" in entry.content
        assert "value1" in entry.content

    def test_process_response_part_thinking(self):
        timestamp = datetime(2024, 1, 1, 12, 0, 0, tzinfo=UTC)
        part = ThinkingPart(content="Thinking about logic")
        entry = _process_response_part(part, timestamp)

        assert entry.entry_type == JOURNAL_TYPE_THINKING
        assert entry.content == "Thinking about logic"
        assert entry.timestamp == timestamp

    def test_process_response_part_text(self):
        timestamp = datetime(2024, 1, 1, 12, 0, 0, tzinfo=UTC)
        part = TextPart(content="Final answer")
        entry = _process_response_part(part, timestamp)

        assert entry.entry_type == JOURNAL_TYPE_TEXT
        assert entry.content == "Final answer"
        assert entry.timestamp == timestamp

    def test_process_response_part_tool_return(self):
        timestamp = datetime(2024, 1, 1, 12, 0, 0, tzinfo=UTC)
        part = ToolReturnPart(tool_name="test_tool", content="Tool result", tool_call_id="call_1")
        entry = _process_response_part(part, timestamp)

        assert entry.entry_type == JOURNAL_TYPE_TOOL_RETURN
        assert entry.tool_name == "test_tool"
        assert "Tool result" in entry.content
        assert entry.timestamp == timestamp

    def test_extract_intercalated_log(self):
        timestamp = datetime(2024, 1, 1, 12, 0, 0, tzinfo=UTC)

        # Request with tool call
        req = ModelRequest(parts=[ToolCallPart(tool_name="tool_a", args={}, tool_call_id="1")])
        req.timestamp = timestamp

        # Response with thinking and tool return
        # Note: ToolReturnPart is typically in ModelRequest in pydantic-ai structure for history?
        # Wait, ModelRequest contains User/Tool messages. ModelResponse contains Assistant messages.
        # ToolReturnPart is in ModelRequest (role='tool').
        # ThinkingPart/TextPart/ToolCallPart are in ModelResponse.

        # Let's verify pydantic-ai structure assumptions in journal.py
        # journal.py assumes:
        # ModelResponse -> ThinkingPart, TextPart, ToolCallPart
        # ModelRequest -> ToolCallPart (Wait, ToolCallPart in Request? Usually ToolReturnPart is in Request if role=tool)

        # Let's correct the test based on journal.py implementation:
        # journal.py:
        #   ModelResponse: _process_response_part(part) -> handles Thinking, Text, ToolCall(!), ToolReturn(!)
        #   ModelRequest: checks for ToolCallPart

        # This seems a bit mixed in journal.py, but we test the implementation as is.

        resp = ModelResponse(
            parts=[
                ThinkingPart(content="Hmm"),
                TextPart(content="Hello"),
                ToolCallPart(tool_name="tool_b", args={}, tool_call_id="2"),
            ],
            timestamp=timestamp,
        )

        log = extract_intercalated_log([req, resp])

        # req has ToolCallPart? journal.py checks `if isinstance(part, ToolCallPart)` for ModelRequest
        # But ToolCallPart is usually generated by Model (Response).
        # Let's assume journal.py logic is what we test.

        assert len(log) == 4
        # 1 from req (ToolCallPart)
        assert log[0].entry_type == JOURNAL_TYPE_TOOL_CALL
        # 3 from resp (Thinking, Text, ToolCall)
        assert log[1].entry_type == JOURNAL_TYPE_THINKING
        assert log[2].entry_type == JOURNAL_TYPE_TEXT
        assert log[3].entry_type == JOURNAL_TYPE_TOOL_CALL

    def test_extract_journal_content(self):
        messages = [
            ModelResponse(parts=[TextPart(content="Part 1")]),
            ModelRequest(parts=[]),
            ModelResponse(parts=[ThinkingPart(content="skip"), TextPart(content="Part 2")]),
        ]
        content = extract_journal_content(messages)
        assert content == "Part 1\n\nPart 2"

    @patch("egregora.agents.writer.journal.Environment")
    def test_save_journal_to_file(self, mock_env_cls):
        mock_env = MagicMock()
        mock_template = MagicMock()
        mock_template.render.return_value = "Rendered Journal"
        mock_env.get_template.return_value = mock_template
        mock_env_cls.return_value = mock_env

        mock_output = MagicMock()

        params = JournalEntryParams(
            intercalated_log=[JournalEntry("text", "content")],
            window_label="w1",
            output_format=mock_output,
            posts_published=1,
            profiles_updated=0,
            window_start=datetime.now(UTC),
            window_end=datetime.now(UTC),
        )

        doc_id = save_journal_to_file(params)

        assert doc_id is not None
        mock_output.persist.assert_called_once()
        doc = mock_output.persist.call_args[0][0]
        assert doc.type == DocumentType.JOURNAL
        assert doc.content == "Rendered Journal"
        assert doc.metadata["window_label"] == "w1"

    def test_save_journal_empty_log_returns_none(self):
        params = JournalEntryParams(
            intercalated_log=[],
            window_label="w1",
            output_format=MagicMock(),
            posts_published=0,
            profiles_updated=0,
            window_start=datetime.now(UTC),
            window_end=datetime.now(UTC),
        )
        assert save_journal_to_file(params) is None
