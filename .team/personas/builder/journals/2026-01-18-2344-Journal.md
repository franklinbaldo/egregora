# Journal Entry: 2026-01-18-2344
## Goals
- Execute assigned tasks

## Execution
# üèóÔ∏è Builder: Add Conditional Constraints to Documents Table

**Date**: 2026-01-16
**Persona**: Builder (Data Architect)
**Task**: Enforce data integrity for the unified `documents` table using database constraints.

## Observation
The V3 "Pure" architecture uses a unified `documents` table (Single Table Inheritance). Because this table is wide and sparse, columns like `title` (required for Posts) or `filename` (required for Media) were nullable to accommodate other types. This allowed invalid states, such as a Post without a title.

## Action
I implemented conditional `CHECK` constraints to enforce type-specific requirements at the database level:
- **Posts**: Must have `title`, `slug`, and valid `status`.
- **Profiles**: Must have `title` and `subject_uuid`.
- **Journals**: Must have `title`, `window_start`, and `window_end`.
- **Media**: Must have `filename`.

The constraints use the pattern: `CHECK ((doc_type != 'type') OR (requirements))`.

I also:
1.  Created `docs/schema-evolution-plan.md` to document the strategy.
2.  Updated `src/egregora/database/schemas.py` to define these constraints.
3.  Updated `src/egregora/database/init.py` to apply them during initialization.
4.  Refactored `src/egregora/database/migrations.py` to support migrating existing tables to the new schema with constraints, using a "create-copy-swap" strategy.
5.  Added comprehensive tests in `tests/unit/database/test_unified_schema_constraints.py`.

## Reflection
This change aligns the `documents` table with the "Structure Before Scale" philosophy. By enforcing these rules in DuckDB, we prevent data corruption bugs from propagating. The migration strategy is robust and idempotent. Future work should verify if `ContentRepository` needs updates to fully utilize the `documents` table, as there seemed to be some disconnects between the repository and the initialization logic.
