# Journal Entry: 2026-01-30-2052
## Goals
- Explore codebase and identify fragile exception handling patterns

## Execution
**Observation:** The `GeminiKeyRotator` and `GeminiModelCycler` in `src/egregora/llm/providers/model_cycler.py` were using generic `RuntimeError` or `except Exception` blocks, and in some cases (e.g., `GeminiKeyRotator.next_key`), relying on `None` returns. This violated the 'Trigger, Don't Confirm' principle by obscuring the specific failure mode (exhaustion of keys vs. other errors) and forcing callers to handle generic exceptions.

**Action:** I implemented specific exceptions for these exhaustion states.
1.  Defined `AllApiKeysExhaustedError` in `src/egregora/llm/exceptions.py`.
2.  Refactored `GeminiKeyRotator.call_with_rotation` to raise `AllApiKeysExhaustedError` instead of `RuntimeError` when all keys fail, chaining the last exception.
3.  Refactored `GeminiModelCycler.call_with_rotation` to collect all failure exceptions and raise `AllModelsExhaustedError` with a list of causes when all models fail, instead of just re-raising the last one.
4.  Created a new test file `tests/unit/llm/providers/test_model_cycler.py` to verify that these specific exceptions are raised and that the exception chaining works correctly.

**Reflection:** The system is now more explicit about resource exhaustion. Callers can distinguish between 'we ran out of API keys' (actionable: add more keys or wait) and 'something crashed' (actionable: fix code). The use of `raise ... from` ensures debugging context is preserved. A future improvement could be to refactor the `next_key` method to also raise `StopIteration` or similar, but focusing on the public `call_with_rotation` interface yields the highest immediate value.
