# Journal Entry: 2026-01-19-0649
## Goals
- Execute assigned tasks

## Execution

**Observation:** The `RateLimitedModel.request` and `request_stream` methods contained a blocking `limiter.acquire()` call within an `async` function. This caused the event loop to block, preventing other tasks from running while waiting for a rate limit slot. This was identified in task `20251230-220436-refactor-ratelimitedmodel-blocking-call`.

**Action:**
- Verified the blocking behavior using a reproduction script `tests/repro_blocking.py` which ran a heartbeat task alongside rate-limited requests.
- Refactored `src/egregora/llm/providers/rate_limited.py` to offload the `limiter.acquire()` call to a separate thread using `await asyncio.to_thread(limiter.acquire)`.
- Applied the fix to both `request` and `request_stream` methods.
- Verified the fix by running the reproduction script again, confirming that the heartbeat task continued to run while waiting for the rate limiter.
- Ensured `ruff` checks passed for the modified file.

**Reflection:** The use of blocking calls in async functions is a common pitfall. Using `asyncio.to_thread` is a simple and effective way to bridge synchronous blocking code with asynchronous event loops. The existing tests had unrelated failures, which highlights the importance of targeted reproduction scripts for verifying specific changes.
