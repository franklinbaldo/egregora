"""Insight-to-issue workflow for ephemeral persona sessions.

Provides utilities to:
1. Request analysis from any persona running in ephemeral mode
2. Parse structured insights from persona responses
3. Convert insights to GitHub issues

This is a generic workflow that works with ANY persona that outputs
structured insights (Maya, Sentinel, Lore, etc.).
"""

import re
import subprocess
from dataclasses import dataclass
from typing import Any

from repo.core.client import TeamClient
from repo.features.ephemeral_pool import EphemeralSessionPool


@dataclass
class PersonaInsight:
    """Parsed insight from any persona's analysis."""

    title: str
    severity: str  # critical, high, medium, low
    labels: list[str]
    description: str
    user_impact: str
    recommendation: str
    evidence: str

    def to_issue_body(self, persona_id: str = "persona") -> str:
        """Convert insight to GitHub issue body format.

        Args:
            persona_id: The persona that generated this insight.

        Returns:
            Formatted markdown for GitHub issue body.

        """
        severity_emoji = {
            "critical": "ðŸ”´",
            "high": "ðŸŸ ",
            "medium": "ðŸŸ¡",
            "low": "ðŸŸ¢",
        }
        emoji = severity_emoji.get(self.severity.lower(), "âšª")

        return f"""## {emoji} Severity: {self.severity.upper()}

## Description
{self.description}

## User Impact
{self.user_impact}

## Recommendation
{self.recommendation}

## Evidence
{self.evidence}

---
*Generated by {persona_id} (ephemeral session)*
"""


@dataclass
class IssueCreationResult:
    """Result of creating a GitHub issue."""

    success: bool
    issue_number: int | None = None
    issue_url: str | None = None
    error: str | None = None


@dataclass
class AnalysisRequest:
    """Request for a persona to analyze input."""

    content: str  # The content to analyze
    source: str | None = None  # e.g., "support ticket", "user interview", "PR review"
    context: str | None = None  # additional context


@dataclass
class AnalysisResult:
    """Result of persona analysis request."""

    session_id: str
    request_sent: bool
    persona_id: str = ""
    error: str | None = None


class PersonaAnalyst:
    """Generic analyst using ephemeral repoless persona sessions.

    Works with ANY persona that can run in ephemeral mode and output
    structured insights. Uses the existing persona abstraction.

    Example usage:
        # Create analyst for Maya persona
        analyst = PersonaAnalyst(client, repo_info, persona_id="maya")

        # Request analysis (async)
        result = analyst.request_analysis(AnalysisRequest(
            content="Users complain the button is hard to find",
            source="support ticket"
        ))

        # Later, poll for insights and create issues
        insights = poll_persona_insights(client, result.session_id)
        for insight in insights:
            analyst.create_issue_from_insight(insight)

    """

    def __init__(
        self,
        client: TeamClient,
        repo_info: dict[str, str],
        persona_id: str = "maya",
        pool: EphemeralSessionPool | None = None,
        personas_dir: str | None = None,
    ):
        """Initialize persona analyst.

        Args:
            client: TeamClient instance for Jules API calls.
            repo_info: Dict with 'owner' and 'repo' keys for issue creation.
            persona_id: The persona to use (e.g., "maya", "sentinel", "lore").
            pool: Optional EphemeralSessionPool. If not provided, creates one.
            personas_dir: Optional path to personas directory.

        """
        self.client = client
        self.repo_info = repo_info
        self.persona_id = persona_id
        self.pool = pool or EphemeralSessionPool(client)
        self.personas_dir = personas_dir

    def request_analysis(self, request: AnalysisRequest) -> AnalysisResult:
        """Request persona to analyze content.

        This sends an analysis request to the ephemeral persona session.
        The analysis happens asynchronously - poll the session activities
        to get the insights.

        Args:
            request: The analysis request with content to analyze.

        Returns:
            AnalysisResult with session_id and request status.

        """
        # Get or create persona session using generic method
        session_id = self.pool.get_or_create_persona_session(
            persona_id=self.persona_id,
            personas_dir=self.personas_dir,
        )
        if not session_id:
            return AnalysisResult(
                session_id="",
                request_sent=False,
                persona_id=self.persona_id,
                error=f"Failed to get or create {self.persona_id} session",
            )

        # Build the analysis request message
        message = f"""## ðŸ“‹ Analysis Request

**Content to Analyze:**
{request.content}

"""
        if request.source:
            message += f"**Source:** {request.source}\n\n"
        if request.context:
            message += f"**Context:** {request.context}\n\n"

        message += """Please analyze this and provide a structured insight
using the format specified in your instructions.
"""

        # Send the analysis request
        try:
            self.client.send_message(session_id, message)
            print(f"  Sent analysis request to {self.persona_id} session {session_id}")
            return AnalysisResult(
                session_id=session_id,
                request_sent=True,
                persona_id=self.persona_id,
            )
        except Exception as e:
            return AnalysisResult(
                session_id=session_id,
                request_sent=False,
                persona_id=self.persona_id,
                error=str(e),
            )

    def create_issue_from_insight(
        self,
        insight: PersonaInsight,
        dry_run: bool = False,
    ) -> IssueCreationResult:
        """Create a GitHub issue from a persona insight.

        Uses the gh CLI to create the issue.

        Args:
            insight: The parsed insight to create an issue from.
            dry_run: If True, don't actually create the issue.

        Returns:
            IssueCreationResult with issue details or error.

        """
        owner = self.repo_info["owner"]
        repo = self.repo_info["repo"]

        # Build labels list
        labels = insight.labels.copy()
        labels.append(f"severity:{insight.severity}")
        labels.append(f"{self.persona_id}-generated")
        labels_str = ",".join(labels)

        # Build issue title with severity prefix
        title = f"[{insight.severity.upper()}] {insight.title}"

        # Build issue body
        body = insight.to_issue_body(persona_id=self.persona_id)

        if dry_run:
            print(f"  [DRY RUN] Would create issue: {title}")
            print(f"  Labels: {labels_str}")
            return IssueCreationResult(
                success=True,
                issue_number=0,
                issue_url="(dry run)",
            )

        # Create issue using gh CLI
        try:
            result = subprocess.run(
                [
                    "gh", "issue", "create",
                    "--repo", f"{owner}/{repo}",
                    "--title", title,
                    "--body", body,
                    "--label", labels_str,
                ],
                capture_output=True,
                text=True,
                timeout=30,
            )

            if result.returncode != 0:
                return IssueCreationResult(
                    success=False,
                    error=f"gh issue create failed: {result.stderr}",
                )

            # Parse issue URL from output
            issue_url = result.stdout.strip()
            # Extract issue number from URL
            issue_number = None
            if "/issues/" in issue_url:
                try:
                    issue_number = int(issue_url.split("/issues/")[-1])
                except (ValueError, IndexError):
                    pass

            print(f"  Created issue: {issue_url}")
            return IssueCreationResult(
                success=True,
                issue_number=issue_number,
                issue_url=issue_url,
            )

        except subprocess.TimeoutExpired:
            return IssueCreationResult(
                success=False,
                error="gh issue create timed out",
            )
        except FileNotFoundError:
            return IssueCreationResult(
                success=False,
                error="gh CLI not found - install GitHub CLI",
            )
        except Exception as e:
            return IssueCreationResult(
                success=False,
                error=str(e),
            )


def parse_persona_insight(response_text: str) -> PersonaInsight | None:
    """Parse a persona's response into a structured insight.

    Expects the response to contain a markdown block with YAML frontmatter
    in the standard insight format (title, severity, labels, sections).

    Args:
        response_text: The raw response text from persona session.

    Returns:
        Parsed PersonaInsight, or None if parsing fails.

    """
    # Try to find the markdown block with frontmatter
    # Pattern: ```markdown\n---\n...\n---\n...\n```
    md_block_pattern = r"```markdown\s*\n(---\n.*?---\n.*?)```"
    match = re.search(md_block_pattern, response_text, re.DOTALL)

    if match:
        content = match.group(1)
    else:
        # Try without code block wrapper
        content = response_text

    # Parse YAML frontmatter
    frontmatter_pattern = r"---\s*\n(.*?)\n---"
    fm_match = re.search(frontmatter_pattern, content, re.DOTALL)

    if not fm_match:
        return None

    frontmatter = fm_match.group(1)

    # Extract fields from frontmatter
    title = ""
    severity = "medium"
    labels: list[str] = []

    for line in frontmatter.split("\n"):
        line = line.strip()
        if line.startswith("title:"):
            title = line.split(":", 1)[1].strip().strip('"\'')
        elif line.startswith("severity:"):
            severity = line.split(":", 1)[1].strip().lower()
        elif line.startswith("labels:"):
            # Parse labels list: [label1, label2] or label1, label2
            labels_str = line.split(":", 1)[1].strip()
            labels_str = labels_str.strip("[]")
            labels = [l.strip().strip('"\'') for l in labels_str.split(",")]

    if not title:
        return None

    # Extract body sections
    body = content[fm_match.end():].strip()

    description = _extract_section(body, "Description")
    user_impact = _extract_section(body, "User Impact")
    recommendation = _extract_section(body, "Recommendation")
    evidence = _extract_section(body, "Evidence")

    return PersonaInsight(
        title=title,
        severity=severity,
        labels=labels,
        description=description,
        user_impact=user_impact,
        recommendation=recommendation,
        evidence=evidence,
    )


def _extract_section(body: str, section_name: str) -> str:
    """Extract content from a markdown section.

    Args:
        body: The markdown body text.
        section_name: The section header to find (without ##).

    Returns:
        The section content, or empty string if not found.

    """
    pattern = rf"##\s*{section_name}\s*\n(.*?)(?=\n##|\Z)"
    match = re.search(pattern, body, re.DOTALL | re.IGNORECASE)
    if match:
        return match.group(1).strip()
    return ""


def poll_persona_insights(
    client: TeamClient,
    session_id: str,
    create_time_after: str | None = None,
) -> list[PersonaInsight]:
    """Poll a persona session for new insights.

    Args:
        client: TeamClient instance.
        session_id: The persona session ID to poll.
        create_time_after: Optional timestamp to only get new activities.

    Returns:
        List of parsed PersonaInsight objects from new activities.

    """
    try:
        activities = client.get_activities(
            session_id,
            create_time_after=create_time_after,
        ).get("activities", [])
    except Exception as e:
        print(f"  Failed to get activities: {e}")
        return []

    insights = []
    for activity in activities:
        # Only process agent messages
        if activity.get("originator", "").upper() != "AGENT":
            continue

        # Get message text
        text = activity.get("text") or ""
        agent_msg = activity.get("agentMessaged", {})
        if not text and agent_msg:
            text = agent_msg.get("agentMessage", "")

        if not text:
            continue

        # Try to parse as Maya insight
        insight = parse_persona_insight(text)
        if insight:
            insights.append(insight)

    return insights
