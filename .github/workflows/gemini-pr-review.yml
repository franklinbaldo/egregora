name: Gemini PR Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  issue_comment:
    types: [created]

# Allow concurrent runs - don't cancel in-progress Gemini reviews (they cost API credits)
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.event.issue.number }}
  cancel-in-progress: false

permissions:
  contents: read
  pull-requests: write

jobs:
  gemini-review:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    # Run if:
    # 1. It's a non-draft PR (automatic trigger)
    # 2. OR it's a comment on a PR containing @gemini (manual trigger)
    if: |
      (github.event_name == 'pull_request' && !github.event.pull_request.draft) ||
      (github.event_name == 'issue_comment' && github.event.issue.pull_request && contains(github.event.comment.body, '@gemini'))

    steps:
      - name: Get PR details
        id: pr
        uses: actions/github-script@v8
        with:
          script: |
            let prNumber, prData;

            if (context.eventName === 'issue_comment') {
              // Manual trigger via @gemini comment
              prNumber = context.issue.number;
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              prData = pr;

              // Extract any additional instructions after @gemini
              const match = context.payload.comment.body.match(/@gemini\s*(.*)/s);
              const userInstructions = match ? match[1].trim() : '';
              core.setOutput('user_instructions', userInstructions);
              core.setOutput('trigger_mode', 'manual');
            } else {
              // Automatic trigger on PR event
              prNumber = context.payload.pull_request.number;
              prData = context.payload.pull_request;
              core.setOutput('user_instructions', '');
              core.setOutput('trigger_mode', 'automatic');
            }

            core.setOutput('pr_number', prNumber);
            core.setOutput('base_sha', prData.base.sha);
            core.setOutput('base_ref', prData.base.ref);
            core.setOutput('head_sha', prData.head.sha);
            core.setOutput('pr_title', prData.title);
            core.setOutput('pr_author', prData.user.login);
            core.setOutput('pr_body', prData.body || '(No description provided)');

      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Collect PR diff and context
        id: collect
        env:
          BASE_SHA: ${{ steps.pr.outputs.base_sha }}
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
          HEAD_SHA: ${{ steps.pr.outputs.head_sha }}
          PR_TITLE: ${{ steps.pr.outputs.pr_title }}
          PR_BODY: ${{ steps.pr.outputs.pr_body }}
          USER_INSTRUCTIONS: ${{ steps.pr.outputs.user_instructions }}
          TRIGGER_MODE: ${{ steps.pr.outputs.trigger_mode }}
        run: |
          set -euo pipefail

          # Ensure we have the base ref locally (works for forks and shallow clones)
          git fetch origin "${BASE_REF}" --depth=1

          # Get unified diff between base and head
          git diff --unified=3 "origin/${BASE_REF}" "${HEAD_SHA}" > pr.diff

          # Trim diff to avoid blowing the context window (90KB ~= 22k tokens)
          head -c 90000 pr.diff > pr-trimmed.diff

          # Get commit messages to understand intent
          # Format: hash - subject + body (if any)
          git log --format="%h - %s%n%b" "origin/${BASE_REF}..${HEAD_SHA}" > commits.txt || echo "(No commits found)" > commits.txt

          # Read CLAUDE.md for project-specific context
          CLAUDE_MD=""
          if [ -f "CLAUDE.md" ]; then
            CLAUDE_MD=$(cat CLAUDE.md)
          fi

          # Output diff and context for the next step
          # Use unique delimiters to avoid conflicts with diff content
          DIFF_DELIMITER="ghadelimiter_diff_$(uuidgen)"
          CLAUDE_DELIMITER="ghadelimiter_claude_$(uuidgen)"
          COMMITS_DELIMITER="ghadelimiter_commits_$(uuidgen)"
          PR_BODY_DELIMITER="ghadelimiter_pr_body_$(uuidgen)"

          {
            echo "diff<<${DIFF_DELIMITER}"
            cat pr-trimmed.diff
            echo "${DIFF_DELIMITER}"
            echo "claude_md<<${CLAUDE_DELIMITER}"
            echo "$CLAUDE_MD"
            echo "${CLAUDE_DELIMITER}"
            echo "commits<<${COMMITS_DELIMITER}"
            cat commits.txt
            echo "${COMMITS_DELIMITER}"
            echo "pr_body<<${PR_BODY_DELIMITER}"
            echo "$PR_BODY"
            echo "${PR_BODY_DELIMITER}"
            echo "user_instructions=$USER_INSTRUCTIONS"
            echo "trigger_mode=$TRIGGER_MODE"
          } >> "$GITHUB_OUTPUT"

      # Construct the shared prompt dynamically after collection using JS for safety
      - name: Construct Gemini Prompt
        id: construct_prompt
        uses: actions/github-script@v8
        env:
          DIFF: ${{ steps.collect.outputs.diff }}
          CLAUDE_MD: ${{ steps.collect.outputs.claude_md }}
          COMMITS: ${{ steps.collect.outputs.commits }}
          PR_BODY: ${{ steps.collect.outputs.pr_body }}
          PR_TITLE: ${{ steps.pr.outputs.pr_title }}
          PR_AUTHOR: ${{ steps.pr.outputs.pr_author }}
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
          USER_INSTRUCTIONS: ${{ steps.collect.outputs.user_instructions }}
          TRIGGER_MODE: ${{ steps.collect.outputs.trigger_mode }}
        with:
          script: |
            const prompt = `You are a senior software engineer and code reviewer for the **egregora** repository.

            ## Project Context

            Egregora is a privacy-first AI pipeline that extracts structured knowledge from unstructured communication.
            - **Stack:** Python 3.12+ | uv | Ibis | DuckDB | Pydantic-AI | Google Gemini
            - **Core Principle:** Privacy before intelligence (names ‚Üí UUIDs before LLM)
            - **Philosophy:** Alpha mindset‚Äîclean breaks over backward compatibility
            - **Architecture:** Three-layer functional (orchestration ‚Üí transformations/adapters ‚Üí data_primitives)

            ## Review Philosophy: Two-Phase Approach

            Your review has **TWO PHASES**. You MUST complete Phase 1 before Phase 2.

            ### Phase 1: Understanding & Steel-Manning (REQUIRED FIRST)

            Before finding issues, **understand what this PR is trying to accomplish and why.**

            1. **Analyze the actual code changes** (PRIMARY SOURCE OF TRUTH):
               - What files changed? What types of changes? (new feature, refactor, bug fix, etc.)
               - What do function/variable names, imports, and patterns tell you about intent?
               - What is the code actually doing when executed?

            2. **Read the stated intent** (SECONDARY - may be incomplete/missing):
               - PR title and description (below)
               - Commit messages (below)
               - ‚ö†Ô∏è **WARNING:** These are often incomplete, vague, or missing entirely.

            3. **Reconcile and steel-man**:
               - Does the stated intent match the actual code changes?
               - If there's a gap, what's the STRONGEST interpretation based on the code?
               - What legitimate reasons might justify this approach?
               - What constraints might the author be working under?

            4. **Define success criteria**:
               - What are the primary objectives of this PR?
               - What does "working correctly" mean for these changes?

            ### Phase 2: Critical Evaluation (ONLY AFTER UNDERSTANDING)

            Now that you understand the intent, evaluate the execution:

            5. **Correctness**:
               - Does it achieve the stated/inferred objectives?
               - Are there bugs or logic errors?

            6. **Implementation Quality**:
               - Is the approach sound given the constraints?
               - Are there simpler alternatives that still meet the goals?
               - Does it follow egregora patterns? (see CLAUDE.md below)

            7. **Safety & Non-Functional Requirements**:
               - üî¥ **CRITICAL:** Privacy bypasses, PII leaks, security vulnerabilities, data loss
               - üü° **IMPORTANT:** Performance issues, missing tests, architecture violations
               - üü¢ **MINOR:** Style, naming (mention only if significant)

            **Tone:** Professional, empathetic but direct, concise, actionable. No fluff.

            ---

            ## Pull Request Details

            - **Repository:** ${{ github.repository }}
            - **PR #${process.env.PR_NUMBER}:** ${process.env.PR_TITLE}
            - **Author:** @${process.env.PR_AUTHOR}

            **Trigger Mode:** ${process.env.TRIGGER_MODE}
            ${process.env.USER_INSTRUCTIONS ? `**User Request:** ${process.env.USER_INSTRUCTIONS}` : ''}

            ### PR Description

            \`\`\`
            ${process.env.PR_BODY}
            \`\`\`

            ### Commit Messages

            \`\`\`
            ${process.env.COMMITS}
            \`\`\`

            ## Unified Diff

            \`\`\`diff
            ${process.env.DIFF}
            \`\`\`

            ## Egregora-Specific Patterns & Architecture

            <claude_md>
            ${process.env.CLAUDE_MD}
            </claude_md>

            ---

            ## Output Format

            Structure your review to **separate understanding from evaluation**:

            ### üéØ Intent & Context (Phase 1 Output)

            **What the code actually does:**
            (2-3 sentences describing the actual changes based on the diff)

            **Stated intent:**
            (1 sentence summarizing PR/commit descriptions, or "No description provided" if empty)

            **Reconciliation:**
            - Does stated intent match actual changes? [YES/NO/PARTIAL]
            - Steel-man interpretation: (What's the STRONGEST case for this approach?)

            **Success criteria:**
            - Primary objective 1: ...
            - Primary objective 2: ...

            ### ‚úÖ Does It Achieve Its Goals? (Phase 2 Correctness)

            - **Objective 1:** [‚úÖ Success / ‚ùå Fails / ‚ö†Ô∏è Partial] - Brief explanation
            - **Objective 2:** [‚úÖ Success / ‚ùå Fails / ‚ö†Ô∏è Partial] - Brief explanation

            ### üîç Critical Issues (Phase 2 Safety)

            (MUST flag privacy/security - empty section OK if none)
            - **file.py:45** - üî¥ Description with severity and impact

            ### ‚ö†Ô∏è Implementation Quality (Phase 2 Code Quality)

            (Architecture, patterns, simplicity, tests)
            - **file.py:90** - üü° Issue + suggested alternative (if it still meets objectives)

            ### üí° Suggestions (Phase 2 Nice-to-Haves)

            (Optional improvements that don't block merging)
            - **file.py:120** - üü¢ Suggestion

            ### üèóÔ∏è Egregora Patterns Compliance

            - **Privacy-first:** [‚úÖ / ‚ùå / N/A] - Brief note
            - **Ibis over pandas:** [‚úÖ / ‚ùå / N/A] - Brief note
            - **Functional transforms:** [‚úÖ / ‚ùå / N/A] - Brief note
            - **Schema preservation:** [‚úÖ / ‚ùå / N/A] - Brief note
            - **Breaking changes documented:** [‚úÖ / ‚ùå / N/A] - Check CLAUDE.md

            ### ‚úÖ Final Verdict

            - **Ready to merge:** [YES / NO / WITH CHANGES]
            - **Top priority action:** (Most important thing to do next, if any)

            ---

            **Word limit:** Keep entire review under 1200 words. Be concise and actionable.`;

            core.exportVariable('GEMINI_PROMPT', prompt);

      # ----------------------------------------------------------------------
      # Gemini Review Pipeline with Fallback Strategy
      # 1. Gemini 2.5 Pro (Best quality, high cost/quota)
      # 2. Gemini 2.5 Flash (Fast, lower cost/quota)
      # 3. Gemini 2.5 Flash Lite (Cheapest, lowest quota usage)
      # ----------------------------------------------------------------------

      - name: Run Gemini PR Review (Pro)
        id: gemini_pro
        continue-on-error: true
        uses: google-github-actions/run-gemini-cli@v0
        with:
          gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
          gemini_model: "gemini-2.5-pro"
          prompt: ${{ env.GEMINI_PROMPT }}

      - name: Run Gemini PR Review (Flash)
        id: gemini_flash
        if: steps.gemini_pro.outcome == 'failure'
        continue-on-error: true
        uses: google-github-actions/run-gemini-cli@v0
        with:
          gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
          gemini_model: "gemini-2.5-flash"
          prompt: ${{ env.GEMINI_PROMPT }}

      - name: Run Gemini PR Review (Flash Lite)
        id: gemini_lite
        if: steps.gemini_pro.outcome == 'failure' && steps.gemini_flash.outcome == 'failure'
        continue-on-error: true
        uses: google-github-actions/run-gemini-cli@v0
        with:
          gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
          gemini_model: "gemini-2.5-flash-lite"
          prompt: ${{ env.GEMINI_PROMPT }}

      - name: Consolidate Gemini Results
        id: gemini_final
        if: always()
        uses: actions/github-script@v8
        env:
          OUTCOME_PRO: ${{ steps.gemini_pro.outcome }}
          SUMMARY_PRO: ${{ steps.gemini_pro.outputs.summary }}
          OUTCOME_FLASH: ${{ steps.gemini_flash.outcome }}
          SUMMARY_FLASH: ${{ steps.gemini_flash.outputs.summary }}
          OUTCOME_LITE: ${{ steps.gemini_lite.outcome }}
          SUMMARY_LITE: ${{ steps.gemini_lite.outputs.summary }}
        with:
          script: |
            const outcomes = {
              pro: process.env.OUTCOME_PRO,
              flash: process.env.OUTCOME_FLASH,
              lite: process.env.OUTCOME_LITE
            };

            const summaries = {
              pro: process.env.SUMMARY_PRO,
              flash: process.env.SUMMARY_FLASH,
              lite: process.env.SUMMARY_LITE
            };

            let finalOutcome = 'failure';
            let finalSummary = '';
            let finalModel = 'unknown';

            if (outcomes.pro === 'success') {
              finalOutcome = 'success';
              finalSummary = summaries.pro;
              finalModel = 'gemini-2.5-pro';
            } else if (outcomes.flash === 'success') {
              finalOutcome = 'success';
              finalSummary = summaries.flash;
              finalModel = 'gemini-2.5-flash';
            } else if (outcomes.lite === 'success') {
              finalOutcome = 'success';
              finalSummary = summaries.lite;
              finalModel = 'gemini-2.5-flash-lite';
            }

            // Output the results safely
            core.setOutput('outcome', finalOutcome);
            core.setOutput('model', finalModel);

            // For summary, use direct setOutput which handles strings safely
            core.setOutput('summary', finalSummary);

            console.log(`Final Model: ${finalModel}`);
            console.log(`Final Outcome: ${finalOutcome}`);

      - name: Check Gemini step result
        if: always()
        run: |
          echo "Gemini pipeline outcome: ${{ steps.gemini_final.outputs.outcome }}"

          if [ "${{ steps.gemini_final.outputs.outcome }}" != "success" ]; then
            echo "::warning::All Gemini CLI attempts failed or were skipped"
            echo "::group::Debugging Information"
            echo "Job status: ${{ job.status }}"
            echo "Pro outcome: ${{ steps.gemini_pro.outcome }}"
            echo "Flash outcome: ${{ steps.gemini_flash.outcome }}"
            echo "Lite outcome: ${{ steps.gemini_lite.outcome }}"
            echo "::endgroup::"
            # Check if API key is set (without exposing it)
            if [ -z "${{ secrets.GEMINI_API_KEY }}" ]; then
              echo "::error::GEMINI_API_KEY secret is not set!"
            else
              echo "GEMINI_API_KEY is set (length: ${#GEMINI_API_KEY})"
            fi
          fi
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}

      - name: Post review as PR comment
        if: always()
        uses: actions/github-script@v8
        env:
          GEMINI_REVIEW: ${{ steps.gemini_final.outputs.summary }}
          GEMINI_OUTCOME: ${{ steps.gemini_final.outputs.outcome }}
          GEMINI_MODEL: ${{ steps.gemini_final.outputs.model }}
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
          TRIGGER_MODE: ${{ steps.collect.outputs.trigger_mode }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            const triggerMode = process.env.TRIGGER_MODE;
            const geminiOutcome = process.env.GEMINI_OUTCOME;
            const geminiModel = process.env.GEMINI_MODEL;

            let review = process.env.GEMINI_REVIEW;
            let body;

            // Add header with trigger mode info
            const triggerEmoji = triggerMode === 'manual' ? 'üëã' : 'ü§ñ';
            const triggerText = triggerMode === 'manual' ? 'Manual review requested' : 'Automatic review';

            if (geminiOutcome !== 'success' || !review) {
              // Gemini step failed - provide diagnostic info
              body = `## ‚ö†Ô∏è Gemini Code Review Failed

            The Gemini CLI review failed to complete after attempting all fallback models (Pro -> Flash -> Lite).

            Possible causes:
            - **API Key Issues:** The \`GEMINI_API_KEY\` secret may be missing or invalid
            - **Quota/Rate Limiting:** All models may be exhausted
            - **Timeout:** The review took longer than the 10-minute job timeout
            - **Context Window:** The PR diff may exceed the context window for all models

            ### Debugging Steps

            1. **Check Secrets:** Verify that \`GEMINI_API_KEY\` is set in repository secrets
            2. **Review Logs:** Check the [workflow run logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for detailed error messages
            3. **Manual Trigger:** Try commenting \`@gemini\` on this PR to re-trigger the review
            4. **Model Status:** Check [Google AI Studio](https://aistudio.google.com/) for model availability

            ---
            *${triggerText} ‚Ä¢ Step outcome: ${geminiOutcome}*`;
            } else {
              // Gemini step succeeded
              body = `## ${triggerEmoji} Gemini Code Review

            ${review}

            ---
            *${triggerText} ‚Ä¢ Generated by ${geminiModel} using official Google GitHub Action*`;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body,
            });

            if (geminiOutcome === 'success') {
              console.log("‚úÖ Review posted successfully!");
            } else {
              console.log("‚ö†Ô∏è Diagnostic comment posted due to Gemini step failure");
            }
