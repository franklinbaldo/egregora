name: Gemini PR Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  issue_comment:
    types: [created]

# Allow concurrent runs - don't cancel in-progress Gemini reviews (they cost API credits)
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.event.issue.number }}
  cancel-in-progress: false

permissions:
  contents: read
  pull-requests: write

jobs:
  gemini-review:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      review_outcome: ${{ steps.gemini_final.outputs.outcome }}
      review_comment: ${{ steps.parse_combined.outputs.review_comment }}
      merge_decision: ${{ steps.parse_combined.outputs.merge }}
      merge_reason: ${{ steps.parse_combined.outputs.merge_reason }}
      merge_risk: ${{ steps.parse_combined.outputs.merge_risk }}
      pr_title: ${{ steps.parse_combined.outputs.pr_title }}
      pr_body: ${{ steps.parse_combined.outputs.pr_body }}

    # Run if:
    # 1. It's a non-draft PR (automatic trigger)
    # 2. OR it's a comment on a PR containing @gemini (manual trigger)
    if: |
      (github.event_name == 'pull_request' && !github.event.pull_request.draft) ||
      (github.event_name == 'issue_comment' && github.event.issue.pull_request && contains(github.event.comment.body, '@gemini'))

    steps:
      - name: Get PR details
        id: pr
        uses: actions/github-script@v8
        with:
          script: |
            let prNumber, prData;

            if (context.eventName === 'issue_comment') {
              // Manual trigger via @gemini comment
              prNumber = context.issue.number;
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              prData = pr;

              // Extract any additional instructions after @gemini
              const match = context.payload.comment.body.match(/@gemini\s*(.*)/s);
              const userInstructions = match ? match[1].trim() : '';
              core.setOutput('user_instructions', userInstructions);
              core.setOutput('trigger_mode', 'manual');
            } else {
              // Automatic trigger on PR event
              prNumber = context.payload.pull_request.number;
              prData = context.payload.pull_request;
              core.setOutput('user_instructions', '');
              core.setOutput('trigger_mode', 'automatic');
            }

            core.setOutput('pr_number', prNumber);
            core.setOutput('base_sha', prData.base.sha);
            core.setOutput('base_ref', prData.base.ref);
            core.setOutput('head_sha', prData.head.sha);
            core.setOutput('pr_title', prData.title);
            core.setOutput('pr_author', prData.user.login);
            core.setOutput('pr_body', prData.body || '(No description provided)');

      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Collect PR diff and context
        id: collect
        env:
          BASE_SHA: ${{ steps.pr.outputs.base_sha }}
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
          HEAD_SHA: ${{ steps.pr.outputs.head_sha }}
          USER_INSTRUCTIONS: ${{ steps.pr.outputs.user_instructions }}
          TRIGGER_MODE: ${{ steps.pr.outputs.trigger_mode }}
        run: |
          set -euo pipefail

          # Create temp directory for files
          mkdir -p .github/tmp

          # Ensure we have the base ref locally
          git fetch --quiet origin "${BASE_REF}" 2>/dev/null || git fetch origin "${BASE_REF}"

          # Get unified diff between base and head, excluding non-code assets
          git diff --unified=1 "origin/${BASE_REF}" "${HEAD_SHA}" -- . ':!uv.lock' ':!.jules/' ':!docs/' ':!README.md' ':!pyproject.toml' ':!tests/v3/infra/sinks/fixtures/' > .github/tmp/diff.txt

          # Truncate diff if too large
          DIFF_SIZE=$(wc -c < .github/tmp/diff.txt)
          MAX_DIFF_SIZE=80000
          if [ "$DIFF_SIZE" -gt "$MAX_DIFF_SIZE" ]; then
            head -c "$MAX_DIFF_SIZE" .github/tmp/diff.txt > .github/tmp/diff_truncated.txt
            echo -e "\n\n... [DIFF TRUNCATED: Original ${DIFF_SIZE} bytes, showing first ${MAX_DIFF_SIZE} bytes] ..." >> .github/tmp/diff_truncated.txt
            mv .github/tmp/diff_truncated.txt .github/tmp/diff.txt
            echo "‚ö†Ô∏è  Diff truncated from $DIFF_SIZE to $MAX_DIFF_SIZE bytes"
          fi

          # Get commit messages
          git log --format="%h - %s" -20 "origin/${BASE_REF}..${HEAD_SHA}" > .github/tmp/commits.txt || echo "(No commits found)" > .github/tmp/commits.txt

          # Output metadata
          {
            echo "user_instructions=$USER_INSTRUCTIONS"
            echo "trigger_mode=$TRIGGER_MODE"
          } >> "$GITHUB_OUTPUT"

          echo "‚úì Collected diff ($(wc -c < .github/tmp/diff.txt) bytes) and commits"

      # Setup Python environment for prompt construction
      - name: Setup Python environment
        uses: ./.github/actions/setup-python-uv
        with:
          python-version: "3.12"
          extras: "--no-dev"

      # Construct the prompt using Python + Jinja2
      - name: Construct Gemini Prompt
        id: construct_prompt
        env:
          REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
          PR_TITLE: ${{ steps.pr.outputs.pr_title }}
          PR_AUTHOR: ${{ steps.pr.outputs.pr_author }}
          PR_BODY: ${{ steps.pr.outputs.pr_body }}
          USER_INSTRUCTIONS: ${{ steps.collect.outputs.user_instructions }}
          TRIGGER_MODE: ${{ steps.collect.outputs.trigger_mode }}
          TEMPLATE_PATH: .github/prompts/pr-review-prompt-improved.md
          DIFF_PATH: .github/tmp/diff.txt
          CLAUDE_MD_PATH: CLAUDE.md
          COMMITS_PATH: .github/tmp/commits.txt
          OUTPUT_PATH: .github/tmp/prompt.txt
        run: |
          set -euo pipefail

          # Construct prompt using Python + Jinja2
          uv run --quiet python .github/scripts/construct_gemini_prompt.py

          # Verify prompt file was created
          if [[ ! -f .github/tmp/prompt.txt ]]; then
            echo "::error::Prompt file was not created"
            exit 1
          fi

          PROMPT_SIZE=$(wc -c < .github/tmp/prompt.txt)
          echo "‚úì Prompt constructed ($PROMPT_SIZE bytes)"

      # Call Gemini API directly with fallback models
      - name: Call Gemini API with fallback models
        id: gemini_final
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          set -euo pipefail

          # Call Gemini API using bash script with built-in fallback
          if bash .github/scripts/call_gemini_api.sh; then
            echo "‚úì Gemini API call succeeded"
          else
            echo "::warning::Gemini API call failed after trying all models"
          fi

          # Read metadata and set outputs
          if [[ -f .github/tmp/gemini_metadata.json ]]; then
            OUTCOME=$(jq -r '.outcome' .github/tmp/gemini_metadata.json)
            MODEL=$(jq -r '.model' .github/tmp/gemini_metadata.json)
            RESPONSE_LENGTH=$(jq -r '.response_length' .github/tmp/gemini_metadata.json)

            echo "outcome=$OUTCOME" >> "$GITHUB_OUTPUT"
            echo "model=$MODEL" >> "$GITHUB_OUTPUT"

            # Store response in output using heredoc
            if [[ -f .github/tmp/gemini_response.txt ]]; then
              {
                echo "summary<<EOF_GEMINI_RESPONSE"
                cat .github/tmp/gemini_response.txt
                echo "EOF_GEMINI_RESPONSE"
              } >> "$GITHUB_OUTPUT"
            fi

            echo "‚úì Outcome: $OUTCOME, Model: $MODEL, Response: $RESPONSE_LENGTH bytes"
          else
            echo "outcome=failure" >> "$GITHUB_OUTPUT"
            echo "model=unknown" >> "$GITHUB_OUTPUT"
            echo "summary=Metadata file not created" >> "$GITHUB_OUTPUT"
            echo "::error::Gemini API call failed: metadata file not created"
          fi

      - name: Parse Combined Response
        id: parse_combined
        if: always()
        uses: actions/github-script@v8
        env:
          GEMINI_RESPONSE: ${{ steps.gemini_final.outputs.summary }}
          GEMINI_OUTCOME: ${{ steps.gemini_final.outputs.outcome }}
        with:
          script: |
            const outcome = process.env.GEMINI_OUTCOME || 'unknown';
            const raw = process.env.GEMINI_RESPONSE || '';

            // Store raw response for debugging
            const preview = raw.length > 500 ? raw.substring(0, 500) + '...[truncated]' : raw;
            core.setOutput('raw_response_preview', preview);

            if (outcome !== 'success') {
              console.log(`Skipping JSON parsing because Gemini outcome is '${outcome}'.`);
              core.setOutput('review_comment', '');
              core.setOutput('merge', 'unknown');
              core.setOutput('merge_reason', 'Gemini review unavailable due to failed API call');
              core.setOutput('merge_risk', 'unknown');
              core.setOutput('pr_title', '');
              core.setOutput('pr_body', '');
              return;
            }

            // Fail fast with specific errors
            if (!raw) {
              throw new Error('GEMINI_RESPONSE_EMPTY: Gemini returned no response');
            }

            // Extract JSON from response
            const jsonMatch = raw.match(/```json\s*([\s\S]*?)\s*```/i) || raw.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
              throw new Error(`NO_JSON_FOUND: Response does not contain JSON. Preview: ${preview}`);
            }

            const candidate = jsonMatch[1] || jsonMatch[0];

            // Parse JSON - let it throw if invalid
            let parsed;
            try {
              parsed = JSON.parse(candidate);
            } catch (error) {
              throw new Error(`JSON_PARSE_ERROR: ${error.message}. JSON candidate: ${candidate.substring(0, 200)}`);
            }

            // Validate required field
            if (!parsed.review_comment || parsed.review_comment.trim() === '') {
              throw new Error('EMPTY_REVIEW_COMMENT: JSON parsed but review_comment field is empty or missing');
            }

            // Extract fields
            core.setOutput('review_comment', parsed.review_comment);
            core.setOutput('merge', String(parsed.merge === true));
            core.setOutput('merge_reason', parsed.merge_reason || 'No reason provided');
            core.setOutput('merge_risk', parsed.merge_risk || 'unknown');
            core.setOutput('pr_title', parsed.pr_title || '');
            core.setOutput('pr_body', parsed.pr_body || '');

            console.log('Successfully parsed Gemini response');

      - name: Update PR Title/Description
        if: steps.gemini_final.outputs.outcome == 'success' && (steps.parse_combined.outputs.pr_title != '' || steps.parse_combined.outputs.pr_body != '')
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
          NEW_TITLE: ${{ steps.parse_combined.outputs.pr_title }}
          NEW_BODY: ${{ steps.parse_combined.outputs.pr_body }}
          CURRENT_TITLE: ${{ steps.pr.outputs.pr_title }}
          CURRENT_BODY: ${{ steps.pr.outputs.pr_body }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            const newTitle = process.env.NEW_TITLE;
            const newBody = process.env.NEW_BODY;
            const currentTitle = process.env.CURRENT_TITLE;
            const currentBody = process.env.CURRENT_BODY;

            const update = {};
            if (newTitle && newTitle !== currentTitle) {
              update.title = newTitle;
            }
            if (newBody && newBody !== currentBody) {
              update.body = newBody;
            }

            if (Object.keys(update).length === 0) {
              console.log('No PR metadata changes to apply.');
              return;
            }

            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              ...update
            });
            console.log('Updated PR metadata:', update);

      - name: Post review as PR comment
        if: always()
        uses: actions/github-script@v8
        env:
          GEMINI_REVIEW: ${{ steps.parse_combined.outputs.review_comment || steps.gemini_final.outputs.summary }}
          GEMINI_OUTCOME: ${{ steps.gemini_final.outputs.outcome }}
          GEMINI_MODEL: ${{ steps.gemini_final.outputs.model }}
          RAW_RESPONSE_PREVIEW: ${{ steps.parse_combined.outputs.raw_response_preview }}
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
          TRIGGER_MODE: ${{ steps.collect.outputs.trigger_mode }}
          RUN_ID: ${{ github.run_id }}
          RUN_ATTEMPT: ${{ github.run_attempt }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            const triggerMode = process.env.TRIGGER_MODE;
            const geminiOutcome = process.env.GEMINI_OUTCOME;
            const geminiModel = process.env.GEMINI_MODEL;
            const rawResponsePreview = process.env.RAW_RESPONSE_PREVIEW;
            const runId = process.env.RUN_ID;
            const runAttempt = process.env.RUN_ATTEMPT;

            let review = process.env.GEMINI_REVIEW;
            let body;

            const triggerEmoji = triggerMode === 'manual' ? 'üëã' : 'ü§ñ';
            const triggerText = triggerMode === 'manual' ? 'Manual review requested' : 'Automatic review';

            if (geminiOutcome !== 'success' || !review) {
              // Build error comment
              body = `## ‚ö†Ô∏è Gemini Code Review Failed

**Failure Type:** Gemini API call failed
**Model:** ${geminiModel || 'none'}
**Outcome:** \`${geminiOutcome}\`

### üîß Troubleshooting Steps

- Verify \`GEMINI_API_KEY\` secret is set correctly
- Check Google AI Studio quota/availability
- Review [workflow logs](../../actions/runs/${runId}/attempts/${runAttempt}) for detailed error messages

${rawResponsePreview ? `### üìÑ Raw Response Preview\n\n\`\`\`\n${rawResponsePreview}\n\`\`\`\n` : ''}

---
*${triggerText}* ‚Ä¢ Run ID: ${runId}`;
            } else {
              // Success
              body = `## ${triggerEmoji} Gemini Code Review

${review}

---
*${triggerText} ‚Ä¢ Generated by ${geminiModel} using Gemini API*`;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body,
            });

            if (geminiOutcome === 'success') {
              console.log("‚úÖ Review posted successfully!");
            } else {
              console.log("‚ö†Ô∏è Diagnostic comment posted due to Gemini failure");
            }

  # This job sets the check status for auto-merge
  review-status:
    name: Review Status Check
    runs-on: ubuntu-latest
    needs: [gemini-review]
    if: always() && github.event_name == 'pull_request'
    steps:
      - name: Set status based on merge decision
        run: |
          OUTCOME="${{ needs.gemini-review.outputs.review_outcome }}"
          MERGE="${{ needs.gemini-review.outputs.merge_decision }}"
          MERGE_REASON="${{ needs.gemini-review.outputs.merge_reason }}"

          echo "Review outcome: $OUTCOME"
          echo "Merge decision: $MERGE"
          echo "Merge reason: $MERGE_REASON"

          if [ -z "${GEMINI_API_KEY:-}" ]; then
            echo "::notice::GEMINI_API_KEY secret is not set; skipping Gemini review gate."
            exit 0
          fi

          if [ "$OUTCOME" != "success" ]; then
            echo "::notice::Gemini review did not complete successfully; not gating this PR."
            exit 0
          fi

          if [ "$MERGE" = "unknown" ] || [ -z "$MERGE" ]; then
            echo "::notice::Gemini merge decision unavailable; not gating this PR."
            exit 0
          fi

          if [ "$MERGE" != "true" ]; then
            echo "‚ùå PR blocked by Gemini merge decision: ${MERGE_REASON}"
            exit 1
          fi

          echo "‚úÖ Review gate passed (merge allowed)"
          exit 0
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
