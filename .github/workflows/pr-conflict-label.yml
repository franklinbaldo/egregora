name: PR Conflict Labeler

on:
  workflow_dispatch:
  pull_request:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  manage-pr:
    name: Manage PR conflicts and updates
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check if fork PR
        id: check_fork
        uses: actions/github-script@v8
        with:
          script: |
            const isFork = context.payload.pull_request ? (context.payload.pull_request.head.repo.full_name !== context.payload.pull_request.base.repo.full_name) : false;
            console.log(`Is fork PR: ${isFork}`);
            core.setOutput('is_fork', isFork.toString());

      - name: Manage conflicts
        id: manage_conflicts
        uses: actions/github-script@v8
        with:
          script: |
            const labelName = 'has-conflicts';
            const isFork = '${{ steps.check_fork.outputs.is_fork }}' === 'true';
            const labelColor = 'd73a4a';
            const labelDescription = 'Pull request has merge conflicts';
            const { owner, repo } = context.repo;

            let pull_number;
            let actor;

            if (context.payload.pull_request) {
              pull_number = context.payload.pull_request.number;
              actor = context.payload.pull_request.user.login;
            } else {
              // Manual trigger - we might want to iterate over all open PRs or just exit
              console.log('Manual trigger - scanning all open PRs');
              const { data: prs } = await github.rest.pulls.list({ owner, repo, state: 'open' });
              // For simplicity, we'll just handle one or tell the user to provide a PR number
              // But let's just use the first Jules PR found for testing
              const julesPr = prs.find(p => p.user.login === 'google-labs-jules[bot]' || p.user.login === 'app/google-labs-jules');
              if (julesPr) {
                pull_number = julesPr.number;
                actor = julesPr.user.login;
                console.log(`Found Jules PR #${pull_number}`);
              } else {
                console.log('No Jules PR found to process.');
                return;
              }
            }

            // Retry logic to wait for GitHub to calculate mergeability
            let prData;
            let attempts = 0;
            const maxAttempts = 5;
            const baseDelay = 2000;

            while (attempts < maxAttempts) {
              attempts++;

              const { data } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number,
              });
              prData = data;

              if (prData.mergeable_state !== 'unknown') {
                break;
              }

              if (attempts < maxAttempts) {
                const delay = baseDelay * Math.pow(2, attempts - 1);
                await new Promise((resolve) => setTimeout(resolve, delay));
              }
            }

            const mergeableState = prData.mergeable_state;
            const isBehind = mergeableState === 'behind';
            const hasConflicts = mergeableState === 'dirty' || prData.mergeable === false;

            console.log(`PR #${pull_number} status: ${mergeableState} (Mergeable: ${prData.mergeable})`);
            core.setOutput('pull_number', pull_number.toString());

            // 1. Label management
            const existingLabels = prData.labels.map((label) => label.name);
            if (hasConflicts) {
              if (!existingLabels.includes(labelName)) {
                await github.rest.issues.addLabels({ owner, repo, issue_number: pull_number, labels: [labelName] });
              }
              if (actor === 'google-labs-jules[bot]' || actor === 'app/google-labs-jules') {
                core.setOutput('trigger_jules_fix', 'true');
              }
            } else if (existingLabels.includes(labelName)) {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: pull_number, name: labelName }).catch(() => {});
            }

            // 2. Auto-update branch if behind and no conflicts
            if (isBehind && prData.mergeable !== false && !isFork) {
              try {
                await github.rest.pulls.updateBranch({ owner, repo, pull_number });
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pull_number,
                  body: 'ðŸ”„ **Branch automatically updated** with latest changes from base branch.'
                });
              } catch (error) {
                console.log(`Branch update failed: ${error.message}`);
              }
            }

      - name: Trigger Jules Conflict Fix
        if: steps.manage_conflicts.outputs.trigger_jules_fix == 'true'
        env:
          JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PYTHONPATH: .claude/skills/jules-api
        run: |
          uv run --with requests python - <<EOF
          import os
          import re
          import subprocess
          import json
          import sys
          from repo_client import JulesClient

          def get_pr_data(pr_number):
              cmd = ["gh", "pr", "view", str(pr_number), "--json", "body,headRefName,title,comments"]
              result = subprocess.run(cmd, capture_output=True, text=True, check=True)
              return json.loads(result.stdout)

          def extract_task_id(body):
              if not body: return None
              match = re.search(r'/task/([a-zA-Z0-9-]+)', body)
              return match.group(1) if match else None

          def has_already_messaged(comments):
              for comment in comments:
                  if "ðŸ¤– **Merge Conflict Detected**" in comment['body']:
                      return True
              return False

          pr_number = "${{ steps.manage_conflicts.outputs.pull_number }}"
          pr_data = get_pr_data(pr_number)
          task_id = extract_task_id(pr_data['body'])

          if not task_id:
              print("No Jules task ID found in PR body. Skipping automation.")
              sys.exit(0)

          if has_already_messaged(pr_data.get('comments', [])):
              print("Already messaged Jules about conflicts for this PR. Skipping to avoid loops.")
              sys.exit(0)

          print(f"Detected conflicts in Jules PR #{pr_number} (Task: {task_id})")

          prompt = f"""
          # ðŸš¨ Merge Conflict Detected

          Your Pull Request #{pr_number} ("{pr_data['title']}") has merge conflicts with the base branch.

          ## Instructions
          1. Resolve the merge conflicts in branch `{pr_data['headRefName']}`.
          2. You should probably sync with the base branch first.
          3. Ensure the code still follows the project conventions and all tests pass.
          4. Commit and push the resolved changes.
          """

          client = JulesClient()
          try:
              print(f"Sending conflict resolution request to session {task_id}...")
              client.send_message(task_id, prompt)

              # Add a marker comment to prevent loops
              msg = "ðŸ¤– **Merge Conflict Detected**: I've notified Jules to resolve the conflicts in this PR."
              subprocess.run(["gh", "pr", "comment", pr_number, "--body", msg], check=True)
              print("Successfully notified Jules.")
          except Exception as e:
              print(f"Failed to send message to Jules: {e}")
          EOF
