name: PR Conflict Labeler

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review

permissions:
  issues: write
  pull-requests: write

jobs:
  manage-pr:
    name: Manage PR conflicts and updates
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    steps:
      - name: Check conflicts and auto-update branch
        uses: actions/github-script@v8
        with:
          script: |
            const labelName = 'has-conflicts';
            const labelColor = 'd73a4a';
            const labelDescription = 'Pull request has merge conflicts';
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;

            // Allow GitHub time to calculate mergeability
            await new Promise((resolve) => setTimeout(resolve, 5000));

            // Retrieve the latest mergeable state
            const { data: prData } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number,
            });

            const mergeableState = prData.mergeable_state;
            const isBehind = mergeableState === 'behind';
            const isClean = mergeableState === 'clean';
            const hasConflicts = mergeableState === 'dirty';

            console.log(`PR Status:
              - State: ${mergeableState}
              - Behind: ${isBehind}
              - Clean: ${isClean}
              - Has conflicts: ${hasConflicts}
              - Mergeable: ${prData.mergeable}
            `);

            // Step 1: Ensure the conflict label exists
            try {
              await github.rest.issues.getLabel({
                owner,
                repo,
                name: labelName,
              });
            } catch (error) {
              if (error.status === 404) {
                try {
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name: labelName,
                    color: labelColor,
                    description: labelDescription,
                  });
                  console.log('Created conflict label');
                } catch (createError) {
                  if (createError.status !== 422) {
                    throw createError;
                  }
                }
              } else {
                throw error;
              }
            }

            // Step 2: Update conflict label
            const existingLabels = prData.labels.map((label) => label.name);

            if (hasConflicts) {
              if (!existingLabels.includes(labelName)) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: pull_number,
                  labels: [labelName],
                });
                console.log('‚úÖ Added conflict label');
              }
            } else if (['clean', 'unstable', 'behind'].includes(mergeableState)) {
              if (existingLabels.includes(labelName)) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: pull_number,
                    name: labelName,
                  });
                  console.log('‚úÖ Removed conflict label');
                } catch (removeError) {
                  if (removeError.status !== 404) {
                    throw removeError;
                  }
                }
              }
            }

            // Step 3: Auto-update branch if behind and no conflicts
            if (isBehind && prData.mergeable !== false) {
              try {
                console.log('Branch is behind and has no conflicts - updating...');

                await github.rest.pulls.updateBranch({
                  owner,
                  repo,
                  pull_number,
                });

                console.log('‚úÖ Branch updated successfully!');

                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pull_number,
                  body: 'üîÑ **Branch automatically updated** with latest changes from base branch.'
                });

              } catch (error) {
                if (error.status === 422) {
                  console.log('‚ö†Ô∏è Branch update not possible (might have restrictions or conflicts)');
                } else if (error.status === 403) {
                  console.log('‚ö†Ô∏è No permission to update branch (might be from a fork)');
                } else {
                  console.error('‚ùå Failed to update branch:', error.message);
                  throw error;
                }
              }
            } else if (hasConflicts) {
              console.log('‚è≠Ô∏è Skipping update - PR has merge conflicts');
            } else if (isClean) {
              console.log('‚úÖ Branch is already up to date');
            } else {
              console.log(`‚ÑπÔ∏è No update needed (state: ${mergeableState})`);
            }
