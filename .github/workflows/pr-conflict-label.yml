name: PR Conflict Labeler

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review

permissions:
  issues: write
  pull-requests: write

jobs:
  label-conflicts:
    runs-on: ubuntu-latest
    steps:
      - name: Update conflict label
        uses: actions/github-script@v8
        with:
          script: |
            const labelName = 'has-conflicts';
            const labelColor = 'd73a4a';
            const labelDescription = 'Pull request has merge conflicts';
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;

            // Retry logic to wait for GitHub to calculate mergeability
            let prData;
            let attempts = 0;
            const maxAttempts = 5;
            const baseDelay = 2000; // Start with 2 seconds

            while (attempts < maxAttempts) {
              attempts++;

              const { data } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number,
              });
              prData = data;

              // If mergeable_state is 'unknown', GitHub is still calculating
              if (prData.mergeable_state !== 'unknown') {
                console.log(`Mergeable state determined after ${attempts} attempt(s): ${prData.mergeable_state}`);
                break;
              }

              if (attempts < maxAttempts) {
                const delay = baseDelay * Math.pow(2, attempts - 1);
                console.log(`Attempt ${attempts}: mergeable_state is 'unknown', waiting ${delay}ms before retry...`);
                await new Promise((resolve) => setTimeout(resolve, delay));
              } else {
                console.log(`Max attempts reached. Final state: ${prData.mergeable_state}`);
              }
            }

            const mergeableState = prData.mergeable_state;

            // Ensure the label exists
            try {
              await github.rest.issues.getLabel({
                owner,
                repo,
                name: labelName,
              });
            } catch (error) {
              if (error.status === 404) {
                try {
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name: labelName,
                    color: labelColor,
                    description: labelDescription,
                  });
                } catch (createError) {
                  if (createError.status !== 422) {
                    throw createError;
                  }
                }
              } else {
                throw error;
              }
            }

            const existingLabels = prData.labels.map((label) => label.name);

            if (mergeableState === 'dirty') {
              if (!existingLabels.includes(labelName)) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: pull_number,
                  labels: [labelName],
                });
              }
            } else if (['clean', 'unstable'].includes(mergeableState)) {
              if (existingLabels.includes(labelName)) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: pull_number,
                    name: labelName,
                  });
                } catch (removeError) {
                  if (removeError.status !== 404) {
                    throw removeError;
                  }
                }
              }
            }

  auto-update-branch:
    name: Auto-update PR branch
    runs-on: ubuntu-latest
    needs: [label-conflicts]
    if: always()
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Update branch if behind and clean
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;

            // Retry logic to wait for GitHub to calculate mergeability
            let prData;
            let attempts = 0;
            const maxAttempts = 5;
            const baseDelay = 2000;

            while (attempts < maxAttempts) {
              attempts++;

              const { data } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number,
              });
              prData = data;

              if (prData.mergeable_state !== 'unknown') {
                console.log(`Mergeable state: ${prData.mergeable_state}`);
                break;
              }

              if (attempts < maxAttempts) {
                const delay = baseDelay * Math.pow(2, attempts - 1);
                console.log(`Waiting ${delay}ms for mergeable state...`);
                await new Promise((resolve) => setTimeout(resolve, delay));
              }
            }

            // Check if branch is behind and clean (no conflicts)
            const isBehind = prData.mergeable_state === 'behind';
            const isClean = prData.mergeable_state === 'clean';
            const hasConflicts = prData.mergeable_state === 'dirty';

            console.log(`PR Status:
              - Behind: ${isBehind}
              - Clean: ${isClean}
              - Has conflicts: ${hasConflicts}
              - Mergeable: ${prData.mergeable}
            `);

            // Only update if behind and no conflicts
            if (isBehind && prData.mergeable !== false) {
              try {
                console.log('Branch is behind and has no conflicts - updating...');

                await github.rest.pulls.updateBranch({
                  owner,
                  repo,
                  pull_number,
                });

                console.log('‚úÖ Branch updated successfully!');

                // Post a comment about the auto-update
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pull_number,
                  body: 'üîÑ **Branch automatically updated** with latest changes from base branch.'
                });

              } catch (error) {
                if (error.status === 422) {
                  console.log('‚ö†Ô∏è Branch update not possible (might have restrictions or conflicts)');
                } else if (error.status === 403) {
                  console.log('‚ö†Ô∏è No permission to update branch (might be from a fork)');
                } else {
                  console.error('‚ùå Failed to update branch:', error.message);
                  throw error;
                }
              }
            } else if (hasConflicts) {
              console.log('‚è≠Ô∏è Skipping update - PR has merge conflicts');
            } else if (isClean) {
              console.log('‚úÖ Branch is already up to date');
            } else {
              console.log(`‚ÑπÔ∏è No update needed (state: ${prData.mergeable_state})`);
            }
