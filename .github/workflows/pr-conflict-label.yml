name: PR Conflict Labeler

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review

permissions:
  issues: write
  pull-requests: write

jobs:
  label-conflicts:
    runs-on: ubuntu-latest
    steps:
      - name: Update conflict label
        uses: actions/github-script@v8
        with:
          script: |
            const labelName = 'has-conflicts';
            const labelColor = 'd73a4a';
            const labelDescription = 'Pull request has merge conflicts';
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;

            // Retry logic to wait for GitHub to calculate mergeability
            let prData;
            let attempts = 0;
            const maxAttempts = 5;
            const baseDelay = 2000; // Start with 2 seconds

            while (attempts < maxAttempts) {
              attempts++;

              const { data } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number,
              });
              prData = data;

              // If mergeable_state is 'unknown', GitHub is still calculating
              if (prData.mergeable_state !== 'unknown') {
                console.log(`Mergeable state determined after ${attempts} attempt(s): ${prData.mergeable_state}`);
                break;
              }

              if (attempts < maxAttempts) {
                const delay = baseDelay * Math.pow(2, attempts - 1);
                console.log(`Attempt ${attempts}: mergeable_state is 'unknown', waiting ${delay}ms before retry...`);
                await new Promise((resolve) => setTimeout(resolve, delay));
              } else {
                console.log(`Max attempts reached. Final state: ${prData.mergeable_state}`);
              }
            }

            const mergeableState = prData.mergeable_state;

            // Ensure the label exists
            try {
              await github.rest.issues.getLabel({
                owner,
                repo,
                name: labelName,
              });
            } catch (error) {
              if (error.status === 404) {
                try {
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name: labelName,
                    color: labelColor,
                    description: labelDescription,
                  });
                } catch (createError) {
                  if (createError.status !== 422) {
                    throw createError;
                  }
                }
              } else {
                throw error;
              }
            }

            const existingLabels = prData.labels.map((label) => label.name);

            if (mergeableState === 'dirty') {
              if (!existingLabels.includes(labelName)) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: pull_number,
                  labels: [labelName],
                });
              }
            } else if (['clean', 'unstable'].includes(mergeableState)) {
              if (existingLabels.includes(labelName)) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: pull_number,
                    name: labelName,
                  });
                } catch (removeError) {
                  if (removeError.status !== 404) {
                    throw removeError;
                  }
                }
              }
            }
