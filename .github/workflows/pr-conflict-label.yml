name: PR Conflict Labeler

on:
  pull_request:  # Changed from pull_request_target for security
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review

permissions:
  contents: write  # Needed for branch updates
  issues: write
  pull-requests: write

jobs:
  manage-pr:
    name: Manage PR conflicts and updates
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    steps:
      - name: Check if fork PR
        id: check_fork
        uses: actions/github-script@v8
        with:
          script: |
            const isFork = context.payload.pull_request.head.repo.full_name !== context.payload.pull_request.base.repo.full_name;
            console.log(`Is fork PR: ${isFork}`);
            core.setOutput('is_fork', isFork.toString());

      - name: Check conflicts and auto-update branch
        uses: actions/github-script@v8
        with:
          script: |
            const labelName = 'has-conflicts';
            const isFork = '${{ steps.check_fork.outputs.is_fork }}' === 'true';
            const labelColor = 'd73a4a';
            const labelDescription = 'Pull request has merge conflicts';
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;

            // Retry logic to wait for GitHub to calculate mergeability
            let prData;
            let attempts = 0;
            const maxAttempts = 5;
            const baseDelay = 2000;

            while (attempts < maxAttempts) {
              attempts++;

              const { data } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number,
              });
              prData = data;

              // If mergeable_state is 'unknown', GitHub is still calculating
              if (prData.mergeable_state !== 'unknown') {
                console.log(`Mergeable state determined after ${attempts} attempt(s): ${prData.mergeable_state}`);
                break;
              }

              if (attempts < maxAttempts) {
                const delay = baseDelay * Math.pow(2, attempts - 1);
                console.log(`Attempt ${attempts}: mergeable_state is 'unknown', waiting ${delay}ms before retry...`);
                await new Promise((resolve) => setTimeout(resolve, delay));
              } else {
                console.log(`Max attempts reached. Final state: ${prData.mergeable_state}`);
              }
            }

            const mergeableState = prData.mergeable_state;
            const isBehind = mergeableState === 'behind';
            const isClean = mergeableState === 'clean';
            const hasConflicts = mergeableState === 'dirty';

            console.log(`PR Status:
              - State: ${mergeableState}
              - Behind: ${isBehind}
              - Clean: ${isClean}
              - Has conflicts: ${hasConflicts}
              - Mergeable: ${prData.mergeable}
            `);

            // Step 1: Ensure the conflict label exists
            try {
              await github.rest.issues.getLabel({
                owner,
                repo,
                name: labelName,
              });
            } catch (error) {
              if (error.status === 404) {
                try {
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name: labelName,
                    color: labelColor,
                    description: labelDescription,
                  });
                  console.log('Created conflict label');
                } catch (createError) {
                  if (createError.status !== 422) {
                    throw createError;
                  }
                }
              } else {
                throw error;
              }
            }

            // Step 2: Update conflict label
            const existingLabels = prData.labels.map((label) => label.name);

            if (hasConflicts) {
              if (!existingLabels.includes(labelName)) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: pull_number,
                  labels: [labelName],
                });
                console.log('‚úÖ Added conflict label');
              }
            } else if (['clean', 'unstable', 'behind'].includes(mergeableState)) {
              if (existingLabels.includes(labelName)) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: pull_number,
                    name: labelName,
                  });
                  console.log('‚úÖ Removed conflict label');
                } catch (removeError) {
                  if (removeError.status !== 404) {
                    throw removeError;
                  }
                }
              }
            }

            // Step 3: Auto-update branch if behind and no conflicts
            // SECURITY: Skip auto-update for fork PRs to prevent potential security issues
            if (isBehind && prData.mergeable !== false && !isFork) {
              try {
                console.log('Branch is behind and has no conflicts - updating...');

                await github.rest.pulls.updateBranch({
                  owner,
                  repo,
                  pull_number,
                });

                console.log('‚úÖ Branch updated successfully!');

                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pull_number,
                  body: 'üîÑ **Branch automatically updated** with latest changes from base branch.'
                });

              } catch (error) {
                if (error.status === 422) {
                  console.log('‚ö†Ô∏è Branch update not possible (might have restrictions or conflicts)');
                } else if (error.status === 403) {
                  console.log('‚ö†Ô∏è No permission to update branch (might be from a fork)');
                } else {
                  console.error('‚ùå Failed to update branch:', error.message);
                  throw error;
                }
              }
            } else if (hasConflicts) {
              console.log('‚è≠Ô∏è Skipping update - PR has merge conflicts');
            } else if (isClean) {
              console.log('‚úÖ Branch is already up to date');
            } else {
              console.log(`‚ÑπÔ∏è No update needed (state: ${mergeableState})`);
            }
