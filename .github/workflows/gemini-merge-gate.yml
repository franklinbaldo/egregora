name: Gemini Merge Gate

on:
  pull_request_target:
    types: [opened, reopened, ready_for_review, synchronize]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  gemini-merge-gate:
    name: Gemini Merge Gate
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      GEMINI_MODEL: ${{ vars.GEMINI_MODEL || 'gemini-3-pro-preview' }}

    steps:
      - name: Capture PR metadata
        id: pr
        uses: actions/github-script@v8
        with:
          result-encoding: string
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed('This workflow only runs for pull_request_target events.');
              return;
            }

            core.setOutput('number', pr.number);
            core.setOutput('title', pr.title || '');
            core.setOutput('author', pr.user?.login || '');
            core.setOutput('url', pr.html_url || '');

      - name: Fetch PR patch (no checkout)
        id: patch
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          MAX_PATCH_BYTES: "120000"
        with:
          result-encoding: string
          script: |
            const prNumber = Number(process.env.PR_NUMBER) || context.payload.pull_request?.number;
            if (!prNumber) {
              core.setFailed('Missing pull request number.');
              return;
            }

            const { data: patchData } = await github.request('GET /repos/{owner}/{repo}/pulls/{pull_number}', {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              headers: { accept: 'application/vnd.github.v3.patch' }
            });

            const rawPatch = typeof patchData === 'string' ? patchData : String(patchData ?? '');
            const maxBytes = parseInt(process.env.MAX_PATCH_BYTES, 10);
            const byteLength = Buffer.byteLength(rawPatch, 'utf8');

            let trimmedPatch = rawPatch.slice(0, maxBytes);
            const truncated = byteLength > maxBytes;

            if (truncated) {
              trimmedPatch += `\n\n[[PATCH TRUNCATED TO ${maxBytes} BYTES FROM ${byteLength} BYTES]]`;
            }

            core.setOutput('patch', trimmedPatch);
            core.setOutput('truncated', truncated ? 'true' : 'false');
            core.setOutput('byte_length', String(byteLength));

      - name: Build Gemini prompt
        id: prompt
        uses: actions/github-script@v8
        env:
          PATCH: ${{ steps.patch.outputs.patch }}
          PATCH_TRUNCATED: ${{ steps.patch.outputs.truncated }}
          PATCH_BYTES: ${{ steps.patch.outputs.byte_length }}
        with:
          result-encoding: string
          script: |
            const pr = context.payload.pull_request;
            const truncated = process.env.PATCH_TRUNCATED === 'true';
            const size = process.env.PATCH_BYTES || 'unknown';

            const prompt = [
              `You are the Gemini Merge Gate for ${context.repo.owner}/${context.repo.repo}.`,
              `Pull Request: #${pr.number} - ${pr.title}`,
              `Author: ${pr.user.login}`,
              `Patch size (bytes): ${size}`,
              `Patch truncated: ${truncated}`,
              '',
              'Decide if this pull request should be allowed to merge based on the provided patch alone. Be conservative when context is limited or truncated.',
              '',
              'Return ONLY valid JSON (no markdown, no code fences) in this shape:',
              '{"merge": true|false, "reason": "<concise justification>", "risk": "low|medium|high"}',
              '',
              'Patch follows between the delimiters:',
              '<<<PATCH START>>>',
              process.env.PATCH,
              '<<<PATCH END>>>'
            ].join('\n');

            core.setOutput('prompt', prompt);

      - name: Evaluate patch with Gemini
        id: gemini
        uses: google-github-actions/run-gemini-cli@v0
        with:
          gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
          gemini_model: ${{ env.GEMINI_MODEL }}
          prompt: ${{ steps.prompt.outputs.prompt }}

      - name: Parse Gemini decision
        id: decision
        if: always()
        uses: actions/github-script@v8
        env:
          GEMINI_OUTCOME: ${{ steps.gemini.outcome }}
          GEMINI_RESULT: ${{ steps.gemini.outputs.summary }}
          PATCH_TRUNCATED: ${{ steps.patch.outputs.truncated }}
          PATCH_BYTES: ${{ steps.patch.outputs.byte_length }}
          GEMINI_MODEL_USED: ${{ env.GEMINI_MODEL }}
        with:
          script: |
            const outcome = process.env.GEMINI_OUTCOME;
            const raw = process.env.GEMINI_RESULT || '';

            let decision = {
              merge: false,
              reason: outcome === 'success' ? 'Gemini response missing' : 'Gemini invocation failed',
              risk: 'high'
            };

            if (outcome === 'success' && raw) {
              const jsonMatch = raw.match(/\{[\s\S]*\}/);
              if (jsonMatch) {
                try {
                  const parsed = JSON.parse(jsonMatch[0]);
                  decision.merge = parsed.merge === true;
                  decision.reason = parsed.reason || 'No reason provided';
                  decision.risk = parsed.risk || 'unknown';
                } catch (error) {
                  decision.reason = `Unable to parse Gemini output: ${error.message}`;
                }
              } else {
                decision.reason = 'Gemini output did not contain JSON.';
              }
            }

            core.setOutput('merge', decision.merge ? 'true' : 'false');
            core.setOutput('reason', decision.reason);
            core.setOutput('risk', decision.risk);
            core.setOutput('truncated', process.env.PATCH_TRUNCATED === 'true' ? 'true' : 'false');
            core.setOutput('patch_bytes', process.env.PATCH_BYTES || 'unknown');
            core.setOutput('model', process.env.GEMINI_MODEL_USED || 'unspecified');

      - name: Comment on PR
        if: always()
        uses: actions/github-script@v8
        env:
          MERGE: ${{ steps.decision.outputs.merge }}
          REASON: ${{ steps.decision.outputs.reason }}
          RISK: ${{ steps.decision.outputs.risk }}
          MODEL: ${{ steps.decision.outputs.model }}
          TRUNCATED: ${{ steps.decision.outputs.truncated }}
          PATCH_BYTES: ${{ steps.decision.outputs.patch_bytes }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            const allowMerge = process.env.MERGE === 'true';

            const lines = [
              `**Gemini Merge Gate (${process.env.MODEL})**`,
              `Decision: ${allowMerge ? '✅ Merge allowed' : '❌ Merge blocked'}`,
              `Reason: ${process.env.REASON}`,
              `Risk: ${process.env.RISK}`,
              `Patch truncated: ${process.env.TRUNCATED === 'true' ? 'yes' : 'no'} (size: ${process.env.PATCH_BYTES} bytes)`
            ];

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: lines.join('\n')
            });

      - name: Write job summary
        if: always()
        run: |
          decision="${{ steps.decision.outputs.merge }}"
          if [ "$decision" = "true" ]; then
            verdict="✅ Merge allowed"
          else
            verdict="❌ Merge blocked"
          fi

          {
            echo "## Gemini Merge Gate"
            echo "- Decision: ${verdict}"
            echo "- Reason: ${{ steps.decision.outputs.reason }}"
            echo "- Risk: ${{ steps.decision.outputs.risk }}"
            echo "- Model: ${{ steps.decision.outputs.model }}"
            echo "- Patch truncated: ${{ steps.decision.outputs.truncated }} (size: ${{ steps.decision.outputs.patch_bytes }} bytes)"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Enforce Gemini decision
        run: |
          if [ "${{ steps.decision.outputs.merge }}" != "true" ]; then
            echo "Gemini Merge Gate blocked merge: ${{ steps.decision.outputs.reason }}"
            exit 1
          fi
