#!/usr/bin/env node

/**
 * Gemini PR Code Review Script
 *
 * This script:
 * 1. Reads the repository bundle (repomix.txt) and PR patch (pr.patch)
 * 2. Sends both to Gemini API for comprehensive code review
 * 3. Posts the review as a comment on the PR
 * 4. Handles long reviews by splitting into multiple comments if needed
 */

const fs = require('fs');
const { execSync } = require('child_process');

// Constants
const GITHUB_API = 'https://api.github.com';
const MAX_COMMENT_LENGTH = 65536; // GitHub's max comment length
const COMMENT_SPLIT_THRESHOLD = 60000; // Leave some buffer

// Environment variables
const {
  GEMINI_API_KEY,
  GEMINI_MODEL = 'gemini-flash-latest',
  GITHUB_TOKEN,
  PR_NUMBER,
  REPO_FULL_NAME,
  TRIGGER_MODE = 'automatic',
  USER_COMMENT = ''
} = process.env;

// Validate required environment variables
if (!GEMINI_API_KEY) {
  console.error('‚ùå Error: GEMINI_API_KEY is required');
  process.exit(1);
}

if (!GITHUB_TOKEN || !PR_NUMBER || !REPO_FULL_NAME) {
  console.error('‚ùå Error: GITHUB_TOKEN, PR_NUMBER, and REPO_FULL_NAME are required');
  process.exit(1);
}

/**
 * Install Gemini SDK
 */
function installDependencies() {
  console.log('üì¶ Installing @google/generative-ai...');
  try {
    execSync('npm install @google/generative-ai', { stdio: 'inherit' });
    console.log('‚úÖ Dependencies installed');
  } catch (error) {
    console.error('‚ùå Failed to install dependencies:', error.message);
    process.exit(1);
  }
}

/**
 * Read file contents
 */
function readFile(filePath) {
  try {
    return fs.readFileSync(filePath, 'utf8');
  } catch (error) {
    console.error(`‚ùå Error reading ${filePath}:`, error.message);
    process.exit(1);
  }
}

/**
 * Format PR conversation from comments JSON
 */
function formatPRConversation(commentsPath) {
  try {
    const commentsData = fs.readFileSync(commentsPath, 'utf8');
    const comments = JSON.parse(commentsData);

    if (!comments || comments.length === 0) {
      return 'No comments yet.';
    }

    return comments.map(comment => {
      const author = comment.user?.login || 'unknown';
      const body = comment.body || '';
      const createdAt = comment.created_at || '';
      return `**@${author}** (${createdAt}):\n${body}`;
    }).join('\n\n---\n\n');
  } catch (error) {
    console.warn(`‚ö†Ô∏è  Could not read PR conversation: ${error.message}`);
    return 'No conversation data available.';
  }
}

/**
 * Create the review prompt for Gemini
 */
function createReviewPrompt(repomixContent, patchContent, conversationContent) {
  const callToAction = TRIGGER_MODE === 'comment' && USER_COMMENT
    ? `\n\n## Request\n\n${USER_COMMENT}`
    : '\n\nPlease provide a code review now, being concise but thorough. Focus on what matters most.';

  return `You are a senior software engineer with exceptional code review skills. Your expertise includes identifying bugs, security vulnerabilities, performance issues, architectural problems, and providing actionable recommendations for improvement.

You will receive:
1. A complete repository context (generated by Repomix)
2. A Git patch showing the changes in this pull request
3. The existing PR conversation to understand what has already been discussed

## Repository Context (Repomix Bundle)

\`\`\`
${repomixContent}
\`\`\`

## Pull Request Changes (Git Patch)

\`\`\`diff
${patchContent}
\`\`\`

## Existing PR Conversation

${conversationContent}

## Your Code Review Skills & Approach

**Review Philosophy:**
- **Be concise but complete** - Every sentence should add value. Avoid verbose explanations.
- **Focus on what's currently relevant** - Consider the existing conversation. Don't repeat what's already been discussed.
- **Prioritize ruthlessly** - Lead with critical issues, de-emphasize minor style points.
- **Be actionable** - Provide specific, implementable suggestions.

You excel at providing **candid, professional reviews** that cover these areas:

### 1. Summary
- Brief overview of what this PR accomplishes
- Overall assessment (approve with minor comments, needs work, etc.)

### 2. Correctness & Bugs
- Logic errors or edge cases not handled
- Potential runtime errors or exceptions
- Incorrect assumptions or implementations

### 3. API/Contracts & Backwards-Compatibility
- Breaking changes to public APIs
- Impact on existing consumers
- Deprecation strategy if applicable

### 4. Security & Privacy
- Authentication/authorization issues
- Data validation and sanitization
- Secrets or sensitive data exposure
- Injection vulnerabilities (SQL, command, etc.)
- Insecure defaults or configurations

### 5. Performance & Complexity
- Algorithmic complexity issues (O(n¬≤) where O(n) is possible)
- Unnecessary database queries or network calls
- Memory leaks or resource management issues
- Caching opportunities

### 6. Testing & Observability
- Test coverage for new/changed code
- Missing test cases or scenarios
- Logging, monitoring, and debugging considerations
- Error handling and observability

### 7. Style & Readability
- Code clarity and maintainability
- Naming conventions
- Comments and documentation
- Consistency with existing codebase patterns

### 8. Architecture/Design Trade-offs
- Design pattern appropriateness
- Separation of concerns
- Code duplication or opportunities for abstraction
- Long-term maintainability considerations

### 9. Actionable Checklist
- Create a prioritized list of specific action items
- Mark critical issues vs. optional improvements
- Be specific with file names and line numbers when possible

## Review Tone & Style

- **Be direct and candid** - point out real issues without sugar-coating
- **Be professional** - constructive criticism, not personal attacks
- **Be specific and concise** - cite exact locations (file:line), use bullet points, avoid paragraphs
- **Skip the obvious** - don't explain basic concepts or repeat what's in the conversation
- **Focus on substance** - avoid unnecessary praise, flattery, or preamble
- **Prioritize impact** - critical security/correctness issues first, minor style last

## Output Format

Return ONLY the Markdown review. Do not include any preamble or meta-commentary about the review itself. Start directly with the review content.

Structure your review using the sections above as Markdown headings (##).${callToAction}`;
}

/**
 * Send review request to Gemini
 */
async function getGeminiReview(repomixContent, patchContent, conversationContent) {
  console.log('ü§ñ Requesting code review from Gemini...');
  console.log(`üìä Model: ${GEMINI_MODEL}`);
  console.log(`üìè Repomix bundle: ${repomixContent.length} chars`);
  console.log(`üìè PR patch: ${patchContent.length} chars`);
  console.log(`üìè PR conversation: ${conversationContent.length} chars`);

  const { GoogleGenerativeAI } = require('@google/generative-ai');
  const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);

  const model = genAI.getGenerativeModel({
    model: GEMINI_MODEL,
    generationConfig: {
      temperature: 0.3, // Lower temperature for more focused, consistent reviews
      topP: 0.95,
      topK: 40,
      maxOutputTokens: 8192,
    },
  });

  const prompt = createReviewPrompt(repomixContent, patchContent, conversationContent);

  try {
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const review = response.text();

    console.log(`‚úÖ Review generated: ${review.length} chars`);
    return review;
  } catch (error) {
    console.error('‚ùå Gemini API error:', error.message);
    if (error.response) {
      console.error('Response data:', JSON.stringify(error.response.data, null, 2));
    }
    throw error;
  }
}

/**
 * Split long review into multiple comments
 */
function splitReview(review) {
  if (review.length <= COMMENT_SPLIT_THRESHOLD) {
    return [review];
  }

  console.log(`üìù Review is ${review.length} chars, splitting into multiple comments...`);

  const parts = [];
  const sections = review.split(/\n(?=##\s)/); // Split on markdown H2 headers

  let currentPart = '';
  let partNumber = 1;

  for (const section of sections) {
    // If adding this section would exceed the threshold, save current part
    if (currentPart.length + section.length > COMMENT_SPLIT_THRESHOLD && currentPart.length > 0) {
      parts.push(`${currentPart}\n\n---\n*Continued in next comment...*`);
      currentPart = `*...continued from previous comment*\n\n`;
      partNumber++;
    }
    currentPart += section + '\n';
  }

  // Add the last part
  if (currentPart.trim()) {
    parts.push(currentPart);
  }

  console.log(`‚úÇÔ∏è  Split into ${parts.length} comments`);
  return parts;
}

/**
 * Post comment to GitHub PR
 */
async function postComment(body, index = 0, total = 1) {
  const url = `${GITHUB_API}/repos/${REPO_FULL_NAME}/issues/${PR_NUMBER}/comments`;

  // Add header to indicate which part this is
  let finalBody = body;
  if (total > 1) {
    const header = `## ü§ñ Gemini Code Review (Part ${index + 1}/${total})\n\n*Model: ${GEMINI_MODEL}*\n\n`;
    finalBody = header + body;
  } else {
    const header = `## ü§ñ Gemini Code Review\n\n*Model: ${GEMINI_MODEL}*\n\n`;
    finalBody = header + body;
  }

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Authorization': `token ${GITHUB_TOKEN}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
        'User-Agent': 'Gemini-PR-Reviewer'
      },
      body: JSON.stringify({ body: finalBody })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`GitHub API responded with ${response.status}: ${errorText}`);
    }

    const data = await response.json();
    console.log(`‚úÖ Comment posted: ${data.html_url}`);
    return data;
  } catch (error) {
    console.error('‚ùå Error posting comment:', error.message);
    throw error;
  }
}

/**
 * Main execution
 */
async function main() {
  console.log('üöÄ Starting Gemini PR Code Review');
  console.log(`üìã PR #${PR_NUMBER} in ${REPO_FULL_NAME}`);
  console.log(`üéØ Trigger mode: ${TRIGGER_MODE}`);
  if (TRIGGER_MODE === 'comment' && USER_COMMENT) {
    console.log(`üí¨ User request: ${USER_COMMENT}`);
  }

  // Install dependencies
  installDependencies();

  // Read input files
  console.log('üìñ Reading input files...');
  const repomixContent = readFile('repomix.txt');
  const patchContent = readFile('pr.patch');
  const conversationContent = formatPRConversation('pr-comments.json');

  // Get review from Gemini
  const review = await getGeminiReview(repomixContent, patchContent, conversationContent);

  // Split review if necessary
  const reviewParts = splitReview(review);

  // Post comments to GitHub
  console.log(`üí¨ Posting ${reviewParts.length} comment(s) to PR...`);
  for (let i = 0; i < reviewParts.length; i++) {
    await postComment(reviewParts[i], i, reviewParts.length);

    // Small delay between comments to avoid rate limiting
    if (i < reviewParts.length - 1) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  console.log('‚ú® Code review completed successfully!');
}

// Run main function
main().catch((error) => {
  console.error('üí• Fatal error:', error);
  process.exit(1);
});
