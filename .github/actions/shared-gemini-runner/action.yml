name: Shared Gemini Runner
description: Run Gemini with a fallback model list and standardized outputs.

inputs:
  prompt:
    description: Prompt to send to Gemini.
    required: true
  fallback_models:
    description: JSON array of Gemini model IDs in preferred order.
    required: true
  gemini_api_key:
    description: API key used to call Gemini.
    required: true

outputs:
  summary:
    description: Gemini response summary from the first successful model.
    value: ${{ steps.run_gemini.outputs.summary }}
  outcome:
    description: Outcome of the Gemini run (success or failure).
    value: ${{ steps.run_gemini.outputs.outcome }}
  model:
    description: Model that produced the selected summary.
    value: ${{ steps.run_gemini.outputs.model }}
  diagnostics:
    description: Human-readable attempt log for troubleshooting.
    value: ${{ steps.run_gemini.outputs.diagnostics }}
  attempts:
    description: JSON array of attempted models in order.
    value: ${{ steps.run_gemini.outputs.attempts }}

runs:
  using: composite
  steps:
    - name: Parse fallback models
      id: models
      uses: actions/github-script@v8
      continue-on-error: true
      env:
        FALLBACK_MODELS: ${{ inputs.fallback_models }}
      with:
        script: |
          const raw = process.env.FALLBACK_MODELS || '';
          let models;
          try {
            const parsed = JSON.parse(raw);
            models = Array.isArray(parsed) ? parsed : [];
          } catch (error) {
            models = raw.split(',').map(s => s.trim()).filter(Boolean);
          }
          if (models.length === 0) {
            models = ['gemini-2.5-pro', 'gemini-2.5-flash', 'gemini-2.5-flash-lite'];
            core.warning('No valid models provided, using defaults.');
          }
          for (let index = 0; index < 3; index++) {
            const value = index < models.length ? models[index] : "";
            core.setOutput(`model_${index}`, value);
          }
          core.setOutput('attempts_json', JSON.stringify(models));

    - name: Run Gemini with Fallback
      id: run_gemini
      shell: bash
      env:
        GEMINI_API_KEY: ${{ inputs.gemini_api_key }}
        PROMPT: ${{ inputs.prompt }}
        MODEL_0: ${{ steps.models.outputs.model_0 }}
        MODEL_1: ${{ steps.models.outputs.model_1 }}
        MODEL_2: ${{ steps.models.outputs.model_2 }}
        ATTEMPTS_JSON: ${{ steps.models.outputs.attempts_json }}
      run: |
        set +e # Allow curl to fail without exiting the script
        models=("$MODEL_0" "$MODEL_1" "$MODEL_2")
        diagnostics=()
        final_outcome="failure"
        final_summary="All Gemini models failed to produce a result."
        final_model=""

        # Use a temporary file for the prompt to handle special characters
        prompt_file=$(mktemp)
        echo "$PROMPT" > "$prompt_file"

        for model in "${models[@]}"; do
          if [ -z "$model" ]; then
            continue
          fi

          echo "Attempting model: $model"

          # Use jq to safely construct the JSON payload from the prompt file
          payload=$(jq -n --arg prompt_text "$(cat "$prompt_file")" \
            '{contents: [{parts: [{text: $prompt_text}]}]}')

          response_file=$(mktemp)
          http_status=$(curl -s -w "%{http_code}" -o "$response_file" \
            -X POST "https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${GEMINI_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$payload")

          if [ "$http_status" -eq 200 ]; then
            echo "Success with model: $model (HTTP $http_status)"
            summary=$(jq -r '.candidates[0].content.parts[0].text // ""' "$response_file")

            if [ -n "$summary" ]; then
              final_outcome="success"
              final_summary="$summary"
              final_model="$model"
              diagnostics+=("Model ($model): Success (HTTP 200)")
              break # Exit loop on first success
            else
              echo "Model $model returned success but with empty content."
              error_message="Empty content in response."
              diagnostics+=("Model ($model): Failed (HTTP 200) - ${error_message}")
              final_summary="Model ${model} failed: ${error_message}"
            fi
          else
            echo "Failure with model: $model (HTTP $http_status)"
            error_message=$(jq -r '.error.message // "Unknown error."' "$response_file")
            diagnostics+=("Model ($model): Failed (HTTP $http_status) - ${error_message}")
            final_summary="Model ${model} failed: ${error_message}"
          fi
        done

        diagnostics_string=$(printf "%s; " "${diagnostics[@]}")

        # Use heredoc for multiline-safe output
        {
          echo "summary<<EOF"
          echo "$final_summary"
          echo "EOF"
          echo "outcome=$final_outcome"
          echo "model=$final_model"
          echo "diagnostics=$diagnostics_string"
          echo "attempts=$ATTEMPTS_JSON"
        } >> "$GITHUB_OUTPUT"

        # Clean up temp files
        rm -f "$prompt_file"
        rm -f "$response_file"
