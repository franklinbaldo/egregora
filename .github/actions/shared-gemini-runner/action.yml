name: Shared Gemini Runner
description: Run Gemini with a fallback model list and standardized outputs.

inputs:
  prompt:
    description: Prompt to send to Gemini.
    required: true
  fallback_models:
    description: JSON array of Gemini model IDs in preferred order.
    required: true
  gemini_api_key:
    description: API key used to call Gemini.
    required: true

outputs:
  summary:
    description: Gemini response summary from the first successful model.
    value: ${{ steps.gemini_curl.outputs.summary }}
  outcome:
    description: Outcome of the Gemini run (success or failure).
    value: ${{ steps.gemini_curl.outputs.outcome }}
  model:
    description: Model that produced the selected summary.
    value: ${{ steps.gemini_curl.outputs.model }}
  diagnostics:
    description: Human-readable attempt log for troubleshooting.
    value: ${{ steps.gemini_curl.outputs.diagnostics }}
  attempts:
    description: JSON array of attempted models in order.
    value: ${{ steps.gemini_curl.outputs.attempts }}

runs:
  using: composite
  steps:
    - name: Run Gemini with curl
      id: gemini_curl
      shell: bash
      env:
        PROMPT: ${{ inputs.prompt }}
        FALLBACK_MODELS: ${{ inputs.fallback_models }}
        GEMINI_API_KEY: ${{ inputs.gemini_api_key }}
      run: |
        set -e
        # Do not use pipefail, as jq might fail on non-json responses, which is expected.

        # 1. Parse models
        raw_models="$FALLBACK_MODELS"
        if ! echo "$raw_models" | jq -e '. | length > 0' > /dev/null 2>&1; then
          echo "::warning::Invalid or empty JSON for fallback_models. Using defaults."
          raw_models='["gemini-2.5-pro", "gemini-2.5-flash", "gemini-2.5-flash-lite"]'
        fi
        mapfile -t models < <(echo "$raw_models" | jq -r '.[]')
        echo "::debug::Attempting models: ${models[*]}"

        # 2. Prepare prompt payload
        # Using jq to safely escape the prompt and construct the JSON payload.
        # This is safer than trying to embed the prompt string directly.
        json_payload=$(jq -n \
          --arg prompt "$PROMPT" \
          '{ "contents": [ { "parts": [ { "text": $prompt } ] } ] }')

        # 3. Loop and call API
        diagnostics=()
        final_summary=""
        final_outcome="failure"
        final_model=""

        for model in "${models[@]}"; do
          echo "Attempting model: $model"
          api_url="https://generativelanguage.googleapis.com/v1beta/models/$model:generateContent?key=$GEMINI_API_KEY"

          # Use a temporary file to store the response body.
          response_file=$(mktemp)

          # Execute curl, capturing HTTP status code and response body.
          # We use -w to write the status code to stdout after the response body.
          http_status=$(curl -s -w "%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -d "$json_payload" \
            "$api_url" \
            -o "$response_file")

          response_body=$(<"$response_file")
          rm -f "$response_file"

          diagnostics+=("Model '$model': HTTP $http_status")

          if [ "$http_status" -eq 200 ]; then
            # Attempt to parse the summary.
            summary=$(echo "$response_body" | jq -r '.candidates[0].content.parts[0].text' 2>/dev/null)

            if [ -n "$summary" ]; then
              echo "Success with model: $model"
              final_summary="$summary"
              final_outcome="success"
              final_model="$model"
              break # Exit loop on first success
            else
              diagnostics+=("Model '$model' response parsing failed. Body: $response_body")
            fi
          else
             diagnostics+=("Model '$model' request failed. Body: $response_body")
          fi
        done

        if [ "$final_outcome" != "success" ]; then
          final_summary="All Gemini API calls failed."
        fi

        # 4. Set outputs
        joined_diagnostics=$(printf "; %s" "${diagnostics[@]}")
        joined_diagnostics=${joined_diagnostics:2}

        {
          echo "summary<<'EOF'"
          echo "$final_summary"
          echo "EOF"
          echo "outcome=$final_outcome"
          echo "model=$final_model"
          echo "diagnostics=$joined_diagnostics"
          echo "attempts=$raw_models"
        } >> "$GITHUB_OUTPUT"
